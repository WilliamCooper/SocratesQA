#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\input colordvi
\usepackage{color}
%\fancyhead{}
%\fancyfoot[CE,CO]{}
\newtoks{\topicofnote} \global\topicofnote={}
\newdimen\longindent \longindent=3.5truein
%\fancyhead[L]{Aircraft Algorithm Memo re: \the\topicofnote \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlst}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\RAFAlgorithmMemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Research Aviation Facility}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Algorithm Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.2truein\leftline{\textcolor{blue}{\textsf{Subject: \the\topicofnote}}}
\leftline{\textcolor{blue}{\textsf{Al Cooper}}}
\leftline{\textcolor{blue}{\textsf{\datetoday}}} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlst}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlst}}
\newcommand{\cc}[1]{\begin{lyxlst}{Attachments:00}
\item [cc:] {#1}
\end{lyxlst}}
\newcommand{\attach}[1]{\begin{lyxlst}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlst}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}
\end_preamble
\use_default_options false
\begin_modules
knitr
\end_modules
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding default
\fontencoding global
\font_roman "times" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command bibtex
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref false
\papersize letterpaper
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type authoryear
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.2in
\topmargin 1in
\rightmargin 1in
\bottommargin 1in
\headheight 1cm
\headsep 2cm
\footskip 0.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title

\series bold
Wind Measurements in SOCRATES:
\series default

\begin_inset Newline newline
\end_inset

An Evaluation of the Pitot-Static Sensor
\begin_inset Newline newline
\end_inset

and the Gust Pod 
\begin_inset Newline newline
\end_inset


\size large
\color black
with suggested processing algorithms
\end_layout

\begin_layout Author
Al Cooper
\end_layout

\begin_layout Date
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
datetoday
\end_layout

\end_inset


\end_layout

\begin_layout Address
National Center for Atmospheric Research
\begin_inset Newline newline
\end_inset

Earth Observing Laboratory
\begin_inset Newline newline
\end_inset

Research Aviation Facility
\begin_inset Newline newline
\end_inset

cooperw@ucar.edu
\end_layout

\begin_layout Standard
\begin_inset VSpace vfill
\end_inset


\begin_inset Newpage cleardoublepage
\end_inset

 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
contentsname}{Table of Contents} 
\end_layout

\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset

 
\begin_inset VSpace vfill
\end_inset


\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
eject
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
abstractname}{Abstract}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{plain}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The gust pod consists of a Rosemount 858 probe installed in an underwing
 instrument canister along with a small CMIGITS inertial unit.
 It is described at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/instruments/all-weather-wind-gust-pod"

\end_inset

.
 The probe is heated to prevent icing and therefore often produces measurements
 in extreme conditions when the standard radome system can becomed blocked
 by icing or frozen lines, so it is a useful backup system.
 In addition, because the five holes in the probe are located close together
 and are connected to pressure transducers by short lines, the instrument
 has the ability to measure high-frequency fluctuations in the wind and
 therefore is a useful complement to the standard wind-sensing system.
 However, the location of the probe below the wing leads to serious distortions
 in the airflow before it reaches the sensor, and these must be considered
 when wind measurements are made.
 The purpose of this note is to document a calculation that addresses this
 problem and that produces wind measurements of quality comparable to those
 from the standard radome-based system.
 In addition, some variance spectra from the gust pod are shown to demonstrate
 its ability to measure fluctuations in the frequency range from 1–10 Hz.
 A second-pass processor is developed and documented that can add the appropriat
e wind variables to an existing netCDF data file.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This documents discusses some of the options for measuring wind in SOCRATES.
 The NSF/NCAR GV has some new capabilities that might improve the measurements
 of wind, but they are not fully investigated and documented yet and in
 some cases the processing algorithms have not be developed.
 This report describes some studies of the new measurements and recommends
 new procedures and processing algorithms for the calculation of wind.
 The result is evidence that the new pitot-static sensor provides a much
 improved measurement of airspeed but still has some residual noise at frequenci
es above about 5
\begin_inset space ~
\end_inset

Hz.
 The gust pod as processed here provides valid measurements of the wind
 that are consistent with the standard system and so could serve as back-up
 measurements to that system.
 However, the variance spectra from the gust pod have several suspicious
 traits and should not be used for spectral analysis without further study.
 An additional result documented here is that the corrections now applied
 to measurements of ambient and dynamic pressure, developed in 2014, remain
 valid and do not need revision.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{abstract}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Plain Layout
set topicofnote to topic of note
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
topicofnote={Gust-Pod Processing for Socrates}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
RAFAlgorithmMemo
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
General scope of this report
\end_layout

\begin_layout Standard
The NCAR Technical Note on 
\begin_inset Quotes eld
\end_inset

Characterization of Uncertainty in Measurements of Wind from the NSF/NCAR
 GV
\begin_inset Quotes erd
\end_inset

 (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

) includes an extensive discussion of the wind-measuring capabilities of
 the GV, and a journal article (
\begin_inset CommandInset citation
LatexCommand citet
key "CooperEtAl2014"

\end_inset

) documented how a laser air-motion sensor can be used to improve those
 measurements.
 In addition, a recent technical note (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2017ncartn"

\end_inset

) presented an approach to improving the measurements through use of a Kalman
 filter.
 In most regards, these studies concluded that the wind measurement from
 the GV has low uncertainty limits and meets most needs of research projects.
 However, one aspect has remained troublesome: The variance spectra of the
 measurements, especially of the longitudinal component of the wind, show
 unacceptable noise.
 This is documented in the 2016 NCAR Technical Note referenced above, in
 an appendix that discusses the high-frequency measurements (titled 
\begin_inset Quotes eld
\end_inset

Turbulence
\begin_inset Quotes erd
\end_inset

).
 Plots in this discussion, taken from a suggestion and analysis by Don Lenschow,
 indicate that the problem is resonance noise in the long lines used to
 connect pressure sensors to the relevant ports.
\end_layout

\begin_layout Standard
In response, RAF has installed a new pitot-static sensor for the measurement
 of the airspeed.
 That instrument uses much shorter lines, so it is hoped that it will reduce
 the noise.
 In addition, the gust pod is being flown in SOCRATES as another candidate
 for making high-frequency measurements, because its lines are still shorter.
 The gust-pod five-hole probe itself is only about an inch in diameter,
 so it may provide the best high-frequency measurements.
 Although the sensor was used before in the DEEPWAVE project and provided
 good measurements, as documented in the 2016 technical note, it is flown
 in a new configuration in SOCRATES that includes the large pods under the
 wings.
 These were not present in DEEPWAVE and apparently change the distortion
 of airflow approaching the gust pod to such a degree that the processing
 developed for DEEPWAVE does not work in SOCRATES.
\end_layout

\begin_layout Standard
One additional source of information about the wind-sensing system is the
 ARISTO-2017 experiment, in which the Laser Air-Motion Sensor (LAMS) was
 flown on the GV\SpecialChar endofsentence
 This provides an opportunity to check and possibly update
 the airspeed calibration reported in the 2014 paper.
 The large pods were present in ARISTO-2017, so if there is any effect on
 the standard system it should be possible to detect it by using these new
 measurements.
\end_layout

\begin_layout Standard
This report is organized into the following major sections:
\end_layout

\begin_layout Itemize
Section 2 discusses the ARISTO-2017 flights and the use of LAMS to check
 the measurement of airspeed.
 
\end_layout

\begin_layout Itemize
Section 3 discusses the new pitot-static sensor and proposes a way to use
 its measurement for the calculation of wind.
 
\end_layout

\begin_layout Itemize
Section 4 develops a new approach to processing the data from the gust pod
 and shows results from that instrument.
\end_layout

\begin_layout Itemize
Section 5 then examines the high-rate measurements available from the standard
 system, the standard system modified to use the pitot-static sensor, and
 the gust-pod system.
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

Summary
\begin_inset Quotes erd
\end_inset

 section then discusses proposed ways to process the data, the relative
 merits of the two new options, and the general status of wind measurements
 a high rate.
 Suggested processing schemes are summarized there for possible use in SOCRATES\SpecialChar endofsentence

 Those processing schemes have been incorporated into the 
\begin_inset Quotes eld
\end_inset

QAtools
\begin_inset Quotes erd
\end_inset

 shiny app (see 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://drive.google.com/open?id=0B1kIUH45ca5AN3VXSnlMOHFWS28"

\end_inset

) so that tests can be made during and after the field campaign by adding
 new processed variables to copies of the netCDF files.
 With appropriate revision, what is proposed can be incorporated into standard
 processing (in 
\begin_inset Quotes eld
\end_inset

nimbus
\begin_inset Quotes erd
\end_inset

), but the second-pass processing may be a better way to add these variables
 in the short term.
\end_layout

\begin_layout Standard
The present text document and the data processing are incorporated into
 a single file, named 
\begin_inset Quotes eld
\end_inset

WindInSOCRATES.Rnw
\begin_inset Quotes erd
\end_inset

, located in the EOL directory ~cooperw/RStudio/SocratesQA/ .
 A 
\begin_inset Quotes eld
\end_inset

Reproducibility
\begin_inset Quotes erd
\end_inset

 Appendix discusses how this work could be duplicated, and all the needed
 components are archived in a GitHub directory, as discussed in that Appendix.
\end_layout

\begin_layout Subsection
Comments related to the standard radome-based system
\begin_inset CommandInset label
LatexCommand label
name "subsec:AKRDcompF"

\end_inset


\end_layout

\begin_layout Standard
The approach to the gust-pod will be to match the results from the radome
 system, so that system is revisited here first.
 A script produced earlier for ORCAS, AKRD.Rnw, implemented second-pass processin
g for AKRD using a complementary-filter approach and developed appropriate
 coefficients and formulas.
 A memo at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://drive.google.com/open?id=0B1kIUH45ca5AaFg4Sk9UWDY5OFE"

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Here and elsewhere in this document, references like 
\begin_inset Quotes eld
\end_inset

this URL
\begin_inset Quotes erd
\end_inset

 are live links to the appropriate documents.
\end_layout

\end_inset

 documents those results, and a presentation made in support of this approach
 is available at this URL
\begin_inset CommandInset href
LatexCommand href
name "at this URL"
target "https://drive.google.com/open?id=0B1kIUH45ca5ALXktNklmdkl3bFU"

\end_inset

.
 Because implementation of that approach is still pending, some of the informati
on is repeated here.
 In addition, data from early SOCRATES flights are added to the data set
 used previously to test that the results are appropriate for SOCRATES.
 (It will be useful to repeat this analysis with additional SOCRATES flights
 when they become available.)
\end_layout

\begin_layout Standard
For reference, the 
\begin_inset Quotes eld
\end_inset

standard
\begin_inset Quotes erd
\end_inset

 representation in use for several years has been
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\alpha=c_{0}+\frac{\Delta p_{\alpha}}{q}\left(c_{1}+c_{2}M\right)
\]

\end_inset

and the coefficients were found by fitting that formula to a reference that
 assumes there is zero vertical wind:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\alpha^{*}=\theta-\frac{w_{p}}{V}
\]

\end_inset


\end_layout

\begin_layout Standard
The justification for this form is that studies of five-hole pressure sensors
 have found a Mach-number dependence that affects their sensitivity.
 
\end_layout

\begin_layout Standard
Here the approach will be different.
 The reference value is split into two components, 
\begin_inset Formula $\alpha^{*}=\alpha_{f}^{*}+\alpha_{s}^{*}$
\end_inset

 that result from applying a Butterworth low-pass filter to 
\begin_inset Formula $\alpha^{*}$
\end_inset

 (in the code, the variable AOAREF) to obtain 
\begin_inset Formula $\alpha_{s}^{*}$
\end_inset

 and then finding 
\begin_inset Formula $\alpha_{f}^{*}$
\end_inset

from 
\begin_inset Formula $\alpha_{f}^{*}=\alpha^{*}-\alpha_{s}^{*}$
\end_inset

.
 These components are then represented by separate fits:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\alpha_{f}=\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{f}(c_{1}+c_{2}M)\label{eq:alpha-fast}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\alpha_{s}=d_{0}+d_{1}\left(\frac{\mathrm{\{ADIFR\}}}{\mathrm{\{QCF\}}}\right)_{s}+d_{2}\mathrm{\{QCF\}}_{s}\label{eq:alpha-slow}
\end{equation}

\end_inset

where the 
\begin_inset Formula $f$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 subscripts represent the high-pass and low-pass components after filtering.
 More complicated representations were tested in both cases, but these appear
 to provide adequate fits without additional terms.
 The 
\begin_inset Formula $c_{2}$
\end_inset

 term representing Mach-number dependence does not appear to be necessary,
 but the expectation that there will be some dependence on 
\begin_inset Formula $M$
\end_inset

 justified its tentative inclusion.
 However, the fits below show no significant difference with 
\begin_inset Formula $c_{2}=0$
\end_inset

, and an analysis of variance made its inclusion appear questionable, so
 it has been dropped from the calculations presented here.
\end_layout

\begin_layout Standard
This approach has two advantages:
\end_layout

\begin_layout Enumerate
The important sensitivity to fluctuations is not compromised by efforts
 to represent the slowly varying zero level for angle of attack.
\end_layout

\begin_layout Enumerate
The slowly varying zero reference can be represented by more complex equations
 without needing to apply those to the high-frequency component.
\end_layout

\begin_layout Standard
The result is an empirical representation that is appropriate for all recent
 GV projects and that does not need to be changed for each project, as has
 been the case for many recent projects that use the standard representation.
 Readers may prefer to jump to Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Measurements-from-LAMS"

\end_inset

 and skip the details of how this representation was developed because this
 information has been presented before at the Research Aviation Facility.
 The rest of this subsection is only a minor update to the previous study
 that uses some of the measurements from SOCRATES.
\end_layout

\begin_layout Subsubsection
Data used in the fit
\end_layout

\begin_layout Standard
The selection of data was described in the previous memo, but that information
 will be repeated here with the addition of SOCRATES data.
 The first step is to assemble the data to be used for fitting.
 The data set should include as many flights and projects as is reasonable,
 but should be reviewed also to eliminate flights that appear anomalous
 because of problems with the measurements, strong updrafts and downdrafts,
 special loading conditions, or other aspects of the flights that make them
 questionable to include.
\end_layout

\begin_layout Standard
In this case, measurements from ORCAS, CSET, DEEPWAVE and early SOCRATES
 were used.
 For CSET, the selected flights were 1, 2, 3, 4, 6, 10, 12, and 16.
 For ORCAS, flights 1, 2, 3, 6, 8, 9, 11, 14, and 16 were selected.
 For DEEPWAVE, all 26 flights were used excepting 6, 7, 15, and 23.
 For SOCRATES, test flight 1 is particularly useful to include because it
 includes the only maneuvers to data.
 Research flights 1 and 2 are the only ones available to data and are needed
 to emphasize the low-level flight segments that are important conditions
 for the measurement of wind, but for now they have been excluded because
 the vertical-wind variance spectra suggest some problem with ADIFR\SpecialChar endofsentence
 To use
 different flights in the future, changes to the 'Project' statements and
 'best' statements will be needed, and in addition it will be necessary
 to change the logical variables 'NewCoefficients' and 'ReloadData' to TRUE.
 Otherwise, this program skips recalculation of the coefficients and just
 retrieves them from the file './AKRD-fit-coef.Rdata' where they have been
 stored by a previous run.
 The process of constructing the data.frame used in the fit, not necessary
 if those previously determined coefficients are to be used, was as follows:
\end_layout

\begin_layout Enumerate
Read the netCDF file as on /scr/raf_data/{Project}, for each flight in CSET
 and ORCAS (not just the ones listed above).
\begin_inset Foot
status open

\begin_layout Plain Layout
For ORCAS flight 12, the available netCDF file was bad and couldn't be read,
 so that flight was skipped.
\end_layout

\end_inset

 
\end_layout

\begin_layout Enumerate
For each file, add appropriate variables for fitting (QR=ADIFR/QCF, M=Mach
 number using uncorrected pressures, AOAREF=PITCH-(GGVSPD/TASF)*180/
\begin_inset Formula $\pi$
\end_inset

, QCF) and the low-pass and high-pass components of these produced by a
 Butterworth third-order filter with cutoff frequency of 1/600 Hz.
 A version of the filter was used that made two passes, one forward and
 one backward, through the data and combined the results.
 Some exploration of values for the cutoff frequency led to similar results
 over a wide range from 0.01
\begin_inset space ~
\end_inset

Hz to 0.001
\begin_inset space ~
\end_inset

Hz, but the choice (1/600)
\begin_inset space ~
\end_inset

Hz appeared to be a good compromise between the conflicting requirements
 to represent the low-pass component well without having it distort the
 high-pass response.
\end_layout

\begin_layout Enumerate
The file was truncated to include only data spanning from the first measurement
 of airspeed above 90
\begin_inset space ~
\end_inset

m/s to the last, to avoid periods when the aircraft was still on the ground
 or just after take-off.
\end_layout

\begin_layout Enumerate
A variable representing flight number was added to each file.
 To avoid ambiguity among projects, ORCAS flights were assigned numbers
 equal to 100 plus the flight number.
 This variable, named RF, then made it possible to identify individual flights
 after all were concatenated.
\end_layout

\begin_layout Enumerate
The individual flights were then concatenated into one data.frame containing
 only the variables needed for fitting and a few others used while examining
 the results.
 The variables in the data.frame were ADIFR, AKRD, GGALT, GGVSPD, PITCH,
 PSF, QCF, ROLL, SSLIP, TASF, TASX, THDG, WIC, and those added in step 2
 above.
\end_layout

\begin_layout Enumerate
From this data frame, another (called DF) was constructed to use in fitting.
 It consisted only of the 17 selected flights listed above.
 In addition, measurements spanning 600
\begin_inset space ~
\end_inset

s from the start and end of each file were removed to avoid periods where
 end-effects seemed to cause problems with the filtered results and also
 to avoid problematic periods during initial climb and final descent, which
 otherwise seemed to distort the fits.
\end_layout

\begin_layout Enumerate
The final data.frame (DF) was then restricted to measurements with TASF >
 110 and ROLL between -2 and 2
\begin_inset Formula $^{\circ}$
\end_inset

, to avoid possible periods of slow flight or in turns.
 Turns in particular invalidate the fit assumption involved in finding the
 reference (AOAREF) used for the fit, so these need to be excluded or turns
 cause serious distortion of the results.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<initialization, include=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

require(knitr)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.path='figure/SO-', echo=FALSE, include=FALSE, fig.lp="fig:",
 dev='png', dpi=100, fig.show='hold', size='footnotesize', replace.assign=TRUE,
 width=49)
\end_layout

\begin_layout Plain Layout

opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
\end_layout

\begin_layout Plain Layout

options(digits=5)
\end_layout

\begin_layout Plain Layout

thisFileName <- "WindInSOCRATES"
\end_layout

\begin_layout Plain Layout

require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
\end_layout

\begin_layout Plain Layout

require(ggplot2)
\end_layout

\begin_layout Plain Layout

require(grid)
\end_layout

\begin_layout Plain Layout

require(ggthemes)
\end_layout

\begin_layout Plain Layout

require(zoo)
\end_layout

\begin_layout Plain Layout

library(scales)
\end_layout

\begin_layout Plain Layout

source('chunks/VSpec.R')  ## temporary, pending inclusion in Ranadu
\end_layout

\begin_layout Plain Layout

source('chunks/removeSpikes.R')
\end_layout

\begin_layout Plain Layout

source('chunks/DemingFit.R')    ## temporary, pending Ranadu update
\end_layout

\begin_layout Plain Layout

source('chunks/SplitDV.R')
\end_layout

\begin_layout Plain Layout

refline <- function (vmin=-100, vmax=100) {
\end_layout

\begin_layout Plain Layout

  lines(c(vmin, vmax), c(vmin, vmax), col='darkorange', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

ReviseProjects <- c('SOCRATES')  ## these are the projects to process 
\end_layout

\begin_layout Plain Layout

nP <- length (ReviseProjects)
\end_layout

\begin_layout Plain Layout

# ReviseProjects <- 'ORCAS'
\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory ()			
\end_layout

\begin_layout Plain Layout

VarList <- c("ADIFR", "GGVSPD", "PITCH", "QCF", "PSF", "AKRD", "WIC", "TASF",
 "GGALT", "ROLL", "PSXC", "ATX", "QCXC")
\end_layout

\begin_layout Plain Layout

## add variables needed to recalculate wind
\end_layout

\begin_layout Plain Layout

VarList <- c(VarList, "TASX", "ATTACK", "SSLIP", "GGVEW", "GGVNS", "VEW",
 "VNS", "THDG")
\end_layout

\begin_layout Plain Layout

SaveRData <- sprintf("%s.Rdata", thisFileName)
\end_layout

\begin_layout Plain Layout

## this controls if new coefficients are calculated and associated plots
 made:
\end_layout

\begin_layout Plain Layout

NewCoefficients <- FALSE
\end_layout

\begin_layout Plain Layout

# NewCoefficients <- TRUE
\end_layout

\begin_layout Plain Layout

source('chunks/SummarizeFit.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<construct-dataframe, eval=NewCoefficients>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

ReloadData <- FALSE  ## have old data for CSET, ORCAS, DEEPWAVE;
\end_layout

\begin_layout Plain Layout

## need new for SOCRATES; for now, do this in all cases
\end_layout

\begin_layout Plain Layout

# ReloadData <- TRUE
\end_layout

\begin_layout Plain Layout

Project <- "ORCAS"
\end_layout

\begin_layout Plain Layout

Data <- data.frame()
\end_layout

\begin_layout Plain Layout

if (ReloadData) {
\end_layout

\begin_layout Plain Layout

  for (flt in 1:19) {
\end_layout

\begin_layout Plain Layout

    if (flt == 12) {next}  ## file is bad
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", Directory,Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 90 and last TASX > 90:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 90]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforORCAS.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 100
\end_layout

\begin_layout Plain Layout

  Data1 <- Data
\end_layout

\begin_layout Plain Layout

  Data <- data.frame()
\end_layout

\begin_layout Plain Layout

  Project <- 'CSET'
\end_layout

\begin_layout Plain Layout

  for (flt in 1:16) {
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", Directory,Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 90 and last TASX > 90:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 90]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforCSET.Rdata')
\end_layout

\begin_layout Plain Layout

  Data1 <- rbind (Data1, Data)
\end_layout

\begin_layout Plain Layout

  Data <- data.frame()
\end_layout

\begin_layout Plain Layout

  Project <- 'DEEPWAVE'
\end_layout

\begin_layout Plain Layout

  for (flt in 1:26) {
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", Directory,Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

    D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

    D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

    D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS
)
\end_layout

\begin_layout Plain Layout

    D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

    ## limit to times between first TASX > 90 and last TASX > 90:
\end_layout

\begin_layout Plain Layout

    TS <- D$Time[D$TASX > 90]
\end_layout

\begin_layout Plain Layout

    TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

    B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

    D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

    Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  save(Data, file='AKRDforDEEPWAVE.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 200
\end_layout

\begin_layout Plain Layout

  Data <- rbind (Data1, Data)
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load(file='AKRDforORCAS.Rdata')
\end_layout

\begin_layout Plain Layout

  Data1 <- Data
\end_layout

\begin_layout Plain Layout

  Data1$RF <- Data1$RF + 100
\end_layout

\begin_layout Plain Layout

  load(file='AKRDforCSET.Rdata')
\end_layout

\begin_layout Plain Layout

  Data <- rbind (Data, Data1)
\end_layout

\begin_layout Plain Layout

  Data1 <- Data
\end_layout

\begin_layout Plain Layout

  load(file='AKRDforDEEPWAVE.Rdata')
\end_layout

\begin_layout Plain Layout

  Data$RF <- Data$RF + 200
\end_layout

\begin_layout Plain Layout

  Data1 <- rbind (Data, Data1)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

## add SOCRATES flights:
\end_layout

\begin_layout Plain Layout

Data <- data.frame()
\end_layout

\begin_layout Plain Layout

Project <- 'SOCRATES'
\end_layout

\begin_layout Plain Layout

for (flt in c(-1, -2, 1, 2, 3, 4)) {
\end_layout

\begin_layout Plain Layout

  if (flt < 0) {
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%stf%02d.nc", Directory,Project,Project,-flt)
\end_layout

\begin_layout Plain Layout

    fno <- 50 - flt
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    fname = sprintf("%s%s/%srf%02d.nc", Directory,Project,Project,flt)
\end_layout

\begin_layout Plain Layout

    fno <- flt
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF (fname, VarList, F=fno)
\end_layout

\begin_layout Plain Layout

  D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

  D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

  D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

  D$AOAREF <- (D$PITCH - (D$GGVSPD / D$TASF) * (180 / pi)) 
\end_layout

\begin_layout Plain Layout

  D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

  D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

  CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

  Rate <- 1
\end_layout

\begin_layout Plain Layout

  D$AOAREFS <- zoo::na.approx (as.vector(D$AOAREF), maxgap=1000*Rate, na.rm
 = FALSE)
\end_layout

\begin_layout Plain Layout

  D$AOAREFS[is.na(D$AOAREFS)] <- 0
\end_layout

\begin_layout Plain Layout

  D$AOAREFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$AOAREFS)
\end_layout

\begin_layout Plain Layout

  D$AOAREFF <-  D$AOAREF - D$AOAREFS
\end_layout

\begin_layout Plain Layout

  D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

  D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

  D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

  D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

  D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

  D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

  D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

  D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

  D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

  ## limit to times between first TASX > 60 and last TASX > 60:
\end_layout

\begin_layout Plain Layout

  TS <- D$Time[D$TASX > 60]
\end_layout

\begin_layout Plain Layout

  TS <- TS[!is.na(TS)]
\end_layout

\begin_layout Plain Layout

  B <- TS[1]; E <- TS[length(TS)]
\end_layout

\begin_layout Plain Layout

  D <- D[D$Time >= B & D$Time <= E,]
\end_layout

\begin_layout Plain Layout

  Data <- rbind (Data, D)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

save(Data, file='AKRDforSOCRATES.Rdata')
\end_layout

\begin_layout Plain Layout

Data$RF <- Data$RF + 300
\end_layout

\begin_layout Plain Layout

Data <- rbind (Data1, Data)
\end_layout

\begin_layout Plain Layout

save(Data, file='AKRDdata.Rdata')  ## this is the all-project data.frame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<reloadIfNeeded, eval=!NewCoefficients>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

load('AKRDdata.Rdata')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@  
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<buildDF, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DF <- data.frame()
\end_layout

\begin_layout Plain Layout

best <- c(1,2,3,6,8,9,11,14,18)+100
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  if (flt == 112) {next}
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

best <- c(1,2,3,4,6,10,12,16)
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

best <- c(1,2,3,4,5,8,9,10,11,12,13,14,16,17,18,19,20,21,22,24,25,26) +
 200
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  if (flt == 112) {next}
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

best <- c(51,52) + 300
\end_layout

\begin_layout Plain Layout

for (flt in best) {
\end_layout

\begin_layout Plain Layout

  D <- Data[Data$RF == flt, ]
\end_layout

\begin_layout Plain Layout

  D <- D[601:(nrow(D)-600), ]
\end_layout

\begin_layout Plain Layout

  DF <- rbind (DF, D)
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\begin_layout Plain Layout

DF <- DF[DF$TASX > 110 & abs(DF$ROLL) < 2, ]
\end_layout

\begin_layout Plain Layout

## now have data.frame DF containing values for fitting
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<fits-to-DF>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if (NewCoefficients) {
\end_layout

\begin_layout Plain Layout

  f <- lm (AOAREF ~ QR + I(QR*M), data=DF)
\end_layout

\begin_layout Plain Layout

  cf <- coef(f)
\end_layout

\begin_layout Plain Layout

  ff <- lm (AOAREFF ~ 0 + QRF, data=DF)
\end_layout

\begin_layout Plain Layout

  cffn <- coef (ff)
\end_layout

\begin_layout Plain Layout

  cff <- 21.481   ## force DEEPWAVE value
\end_layout

\begin_layout Plain Layout

  fs <- lm(AOAREFS~QRS+QCFS, data=DF)
\end_layout

\begin_layout Plain Layout

  cfs <- coef(fs)
\end_layout

\begin_layout Plain Layout

  save (cffn, cff, cfs, ff, fs, file='AKRD-fit-coef.Rdata')
\end_layout

\begin_layout Plain Layout

} else {
\end_layout

\begin_layout Plain Layout

  load (file='AKRD-fit-coef.Rdata')
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Fit results
\end_layout

\begin_layout Standard
The result of fitting using (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-fast"

\end_inset

) was 
\begin_inset Formula $c_{1}=$
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cffn,4)}
\end_layout

\end_inset

, but an earlier fit to more selective speed-run and other data in DEEPWAVE
 suggested a value of 
\begin_inset Formula $c_{1}=21.481$
\end_inset

, as described in the NCAR Technical Note on Wind Uncertainty (
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2016ncartn"

\end_inset

).
 That appears to provide a good representation of the CSET/ORCAS/SOCRATES
 data as well, so that coefficient will be used here.
 For the low-pass component, the coefficients from the fit to (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-slow"

\end_inset

) were {
\begin_inset Formula $d$
\end_inset

} = {
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[1], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[2], 4)}
\end_layout

\end_inset

, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfs[3], 6)}
\end_layout

\end_inset

}, and the residual standard deviation for this fit was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(summary(fs)$sigma, 3)}
\end_layout

\end_inset

.
 These results are discussed further in a presentation that is available
 
\begin_inset CommandInset href
LatexCommand href
name "here"
target "https://drive.google.com/open?id=0B1kIUH45ca5ALXktNklmdkl3bFU"

\end_inset

, where the choice for 
\begin_inset Formula $c_{1}$
\end_inset

 is also explained.
\end_layout

\begin_layout Section
Measurements from LAMS – ARISTO-2017
\begin_inset CommandInset label
LatexCommand label
name "sec:Measurements-from-LAMS"

\end_inset


\end_layout

\begin_layout Standard
The purpose of this section is to consider if the LAMS measurements from
 ARISTO2017 are consistent with the previous study of the PCor function
 as presently documented in the Processing Algorithms Technical Note.
 During this GV project, the LAMS was flown in a 4-beam configuration.
 The beam assignments were non-standard, though: Beam 2 was approximately
 in the forward direction, and beams 1, 3 and 4 were approximately 
\begin_inset Formula $35^{\circ}$
\end_inset

 from the longitudinal axis with beam 1 upward, beam 3 outboard and downward,
 and beam 4 inboard and downward.
 Relative to an azimuthal angle starting from the downward direction they
 were, respectively, 180, 
\begin_inset Formula $60$
\end_inset

 and -60
\begin_inset Formula $^{\circ}$
\end_inset

 in clockwise rotation about the forward longitudinal axis.
 Although there were four beams, the fourth seldom produced useful measurements
 so it will be necessary to use the three-beam solution for the wind vector.
\end_layout

\begin_layout Standard
There were six research flights in ARISTO-2017, but the LAMS was not operational
 on the last two so those will not be used here.
 Research flight 4 was particularly useful because it extended to low level
 and so expanded the envelope of measurements that can constrain the pressure-co
rrection algorithms.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
However, LAMS was not operational before about 20:00:00 UTC on this flight.
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
For ARISTO-2017, the line-of-sight beam speeds were determined in two ways.
 Matt Hayman improved upon the processing method originally used by Scott
 Spuler in the 2014 study.
 This usually worked very well.
 Because there was tight coupling to the expected measured TAS (with adjustment
 for the beam angles), it might be suspect that the method may be biased
 toward the TAS value at times that have a marginal signal.
 Therefore, a second method was to fit the background using Savitzgy-Golay
 polynomials and then search for peaks above this background, as was done
 in the original 2014 PCor determination.
 When signals were strong, the method usually produced the same result as
 the PCA method, but it was more prone to failure during periods where the
 signal was weak.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
(A signal-to-noise test of 
\begin_inset Formula $\geq4$
\end_inset

 was required for a valid measurement.)
\end_layout

\end_inset

 In this report, Matt's processing will be used with additional restrictions
 requiring his estimate of uncertainty to meet specified tests for the measureme
nt to be accepted.
 Because there are many good measurements, this helps avoid cases where
 the measurements might be suspect and perhaps biased toward the standard
 TAS.
\end_layout

\begin_layout Standard
Although there are many uses of the LAMS measurements, as described in previous
 reports and memos, here the focus will be on checking the PCor function
 currently in use and revising it if necessary.
 The function can be found at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://drive.google.com/open?id=0B1kIUH45ca5Aa29JbjJkel82NFU"

\end_inset

, on pages 29–31.
\end_layout

\begin_layout Subsection
Data processing
\end_layout

\begin_layout Standard
The original netCDF files, with names like ARISTO2017rf01.nc, contain 512-element
 arrays of the LAMS frequency measurements each time interval, with names
 like BEAM{1–4}_LAMS.
 For ARISTO-2017, Matt Hayman produced auxiliary files with names like
\begin_inset Newline newline
\end_inset

ARISTO2017rf04_LAMS_TAS_Update.nc .
 These files contain 28 new variables, in particular line-of-sight speeds
 (V_LOS_Beam{1-3} and Cartesian-coordinate velocity components (AIRSPEED_{X,Y,Z}
_LAMS) in the LAMS coordinate system.
 The files also include variables V_LOS_Beamx{1-3}_Uncertainty, estimates
 of the uncertainty in the line-of-sight airspeeds, which have values ranging
 from 0 to 10.
\begin_inset Foot
status open

\begin_layout Plain Layout
It appears that values of 0 are where there is no measurement (e.g., before
 takeoff), values of 10 indicate low-uncertainty estimates that perhaps
 should be excluded from the present study, and the remaining values mostly
 range between 0 and 1 and are the values to be used in this study.
 Most are below 0.1, so it may be useful to consider only those measurements
 with associated uncertainty larger than 0 but smaller than 0.1.
 This needs to be checked with Matt.
\end_layout

\end_inset

 Additional variables (AIRSPEED_{X,Y,Z}_EST) are the result of Kalman-filter
 adjustment using measurements from LAMS and the standard system, so they
 should not be used for the present study.
 Some additional variables are present in these files, but the line-of-sight
 speeds will be the primary input used here.
\end_layout

\begin_layout Standard
The processing chain used for this report was as follows:
\end_layout

\begin_layout Enumerate
A Python routine, with minor modifications from that used previously in
 the 2014 study and the C-130 study that used ARISTO-2015 and ARISTO-2016,
 was used to find line-of-sight airspeeds along all the beams.
 It is LAMS_ARISTO.py and the version used is in the directory ~cooperw/RStudio/A
RISTO-2017.
 It reads the original netCDF file containing the beam histograms in variables
 BEAMx_LAMS, each a 512-element histogram.
\begin_inset Foot
status open

\begin_layout Plain Layout
The long_name attributes are 
\begin_inset Quotes eld
\end_inset

LAMS Histogram Maximums
\begin_inset Quotes erd
\end_inset

 – this should be changed because one must find the peak from the 512-element
 array.
\end_layout

\end_inset

 The new variables produced by this Python routine are BEAMxspeed where
 x is {1–4}.
 
\end_layout

\begin_layout Enumerate
The variables V_LOS_Beam{1,2.3} are produced by Matt's processing.
 They are in separate netCDF files that have only the new variables, so
 they must be merged into the composite data.frame so they can be used convenient
ly with the other standard variables and the BEAMxspeed variables.
 This is done by the R code in the 
\begin_inset Quotes eld
\end_inset

merge: chunk, which is included here for reference and is not executed because
 all four beams have been processed in this way and saved in a composite
 data.frame named DataM.
\begin_inset Foot
status open

\begin_layout Plain Layout
Because the files produced by Matt did not have RAF-standard times, the
 
\begin_inset Quotes eld
\end_inset

merge
\begin_inset Quotes erd
\end_inset

 chunk includes reference to a special version of getNetCDF called getNetCDFMH()
 that assigned the correct times so that the measurements could be merged
 with the Python-produced files.
\end_layout

\end_inset

 The individual flights are identified by the variable RF containing the
 flight number, so individual flights can be selected via, e.g., DataM[DataM$RF=4,
].
\end_layout

\begin_layout Enumerate
The subsequent analysis is then contained in this file (WindInSOCRATES.Rnw).
 Preliminary checks indicated good agreement between Matt's processing and
 the Savitzky-Golay approach, so if this study is repeated in the future
 it will be preferable to omit the Python routine and use only Matt's variables.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<merge, eval=FALSE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## don't run after the first time: saves DataM.Rdata
\end_layout

\begin_layout Plain Layout

source ('chunks/mergeMatt.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although the Python routine calculated horizontal wind variables and other
 results derived from the line-of-sight airspeeds, all such variables were
 recalculated in the present R routine (this file) to generate measurements
 of vertical and horizontal wind, airspeed, and angles of attack and sideslip.
 For airspeed, angle of attack, and sideslip, these steps were used:
\end_layout

\begin_layout Enumerate
The three-beam measurements were used to determine a three-dimensional relative
 wind vector 
\series bold
RW
\series default
={
\begin_inset Formula $\mathrm{RW}_{x},\,\mathrm{RW}_{y},\,\mathrm{RW_{z}}$
\end_inset

}
\series bold
 
\series default
with components inbound along the longitudinal forward, lateral starboard,
 and lateral downward axis in the coordinate frame of the LAMS IRU (with
 attitude angles CPITCH, CROLL, CTHDG).
 The algorithm is documented in 
\begin_inset CommandInset href
LatexCommand href
name "LAMSprocessing4Bwind.pdf"
target "https://drive.google.com/open?id=0B1kIUH45ca5AalZOWHlscnprbnc"

\end_inset

.
 However, the three-beam version is used here.
\end_layout

\begin_layout Enumerate
The airspeed is then the magnitude of the vector 
\series bold
RW
\series default
.
\end_layout

\begin_layout Enumerate
The angle of attack is 
\begin_inset Formula $\alpha=\arctan\left(\mathrm{RW}_{z}/\mathrm{RW}_{x}\right)$
\end_inset

 and the sideslip angle is 
\begin_inset Formula $\beta=\arctan\left(\mathrm{RW}_{y}/\mathrm{RW}_{x}\right)$
\end_inset

.
 These are in the reference frame of the LAMS (i.e., that defined by the CMIGITS
 IRU).
\end_layout

\begin_layout Standard
For measurements of wind, the Ranadu function Ranadu::WindProcessor() was
 used to calculate the wind based on LAMS-based variables for airspeed,
 angle of attack, and sideslip and the CMIGITS-provided attitude angles
 and ground-speed components.
 The complementary-filter adjustment provided by 
\begin_inset Quotes eld
\end_inset

WindProcessor()
\begin_inset Quotes erd
\end_inset

 is suppressed because the Kalman-filter processing in the CMIGITS accounts
 for the GPS-provided measurements of ground speed.
\begin_inset Foot
status open

\begin_layout Plain Layout
Some adjustment may be needed to these values because I think the GPS antenna
 used is the standard one mounted below the fuselage and therefore separated
 from the LAMS pod.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
For completeness, here are suggested procedures for using the Python routine
 LAMS_ARISTO.py, with comments regarding future use with new data files:
\end_layout

\begin_layout Enumerate
On tikal, copy the routine ~cooperw/ARISTO-2017/LAMS_ARISTO.py to another
 directory where you have write permission.
\end_layout

\begin_layout Enumerate
On lines 254 and 255, change the names of the data file and the directory
 containing the file to be processed.
 Do not include the trailing 
\begin_inset Quotes eld
\end_inset

.nc
\begin_inset Quotes erd
\end_inset

 in the file name.
 Save the edited file.
 CAUTION: This routine will create a new file in that same directory as
 the existing file with 
\begin_inset Quotes eld
\end_inset

LAMS
\begin_inset Quotes erd
\end_inset

 appended to the file name, and if that file is present it will be overwritten.
 This won't overwrite Matt's files because it adds 
\begin_inset Quotes eld
\end_inset

LAMS
\begin_inset Quotes erd
\end_inset

 instead of 
\begin_inset Quotes eld
\end_inset

_LAMS
\begin_inset Quotes erd
\end_inset

, but if his files ending in 
\begin_inset Quotes eld
\end_inset

_LAMS
\begin_inset Quotes erd
\end_inset

 are used the new file will end in 
\begin_inset Quotes eld
\end_inset

_LAMSLAMS
\begin_inset Quotes erd
\end_inset

.
 In that case, the new file will contain the line-of-sight speeds obtained
 by both algorithms, in Matt's case with the names Beam1_LAMS – Beam4_LAMS
 and in the case of the Python program with names BEAM1speed – BEAM4speed.
 Note, however, that these will not be used in the following except, when
 present, for comparison tests.
 Instead, Matt's variables 
\begin_inset Quotes eld
\end_inset

V_LOS_Beamx
\begin_inset Quotes erd
\end_inset

 (with x={1,2,3}) will be used.
\end_layout

\begin_layout Enumerate
Run the program using the command 
\begin_inset Quotes eld
\end_inset

python LAMS_ARISTO.py
\begin_inset Quotes erd
\end_inset

.
 There will be regular messages during processing, ending (if successful)
 with the message 
\begin_inset Quotes eld
\end_inset

Reached end of routine ...
\begin_inset Quotes erd
\end_inset

.
 This will typically take a few minutes, maybe as much as 5 min.
 If this fails immediately, there may be a problem with the available python
 packages that need updating or changing.
 In particular, the 
\begin_inset Quotes eld
\end_inset

netCDF4
\begin_inset Quotes erd
\end_inset

 python package must be present.
\end_layout

\begin_layout Enumerate
On successful completion, there should then be a new file with a name ending
 in 
\begin_inset Quotes eld
\end_inset

LAMS.nc
\begin_inset Quotes erd
\end_inset

 in the prescribed working directory.
 It should be slightly larger than the original file because a few variables
 are added containing the line-of-sight LAMS speeds and some derived quantities.
 These are then the netCDF files that are read by the next routine (the
 processor associated with this document) to produce the final document,.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is then to run this routine, 
\begin_inset Quotes eld
\end_inset

WindInSOCRATES.Rnw
\begin_inset Quotes erd
\end_inset

, in RStudio to generate the PDF document.
 That program contains a suppressed R chunk called 'merge' that should be
 executed on the first run to merge Matt's variables into this file.
 After the first run, the program will load the merged data.frame from 
\begin_inset Quotes eld
\end_inset

DataM.Rdata
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Subsection
Results
\end_layout

\begin_layout Standard
The first comparison shown is the along-beam measurements of airspeed from
 LAMS in comparison to the wind vector from the standard wind-sensing system
 projected in the direction of the beams.
 For these plots, the relative-wind vector from the standard radome-based
 system is transformed to the Earth-relative l-frame and then to the reference
 frame of the LAMS, here called the g-frame by analogy to the gust-pod reference
 frame discussed elsewhere.
 This gives the relative-wind vector in the LAMS reference frame, which
 (like the a-frame) has x-axis forward, y-axis starboard and z-axis downward.
 The dot product of the unit vectors representing the orientations of the
 LAMS beams with the LAMS-relative wind then gives the expected along-beam
 airspeeds as predicted from the standard measurement of relative wind.
 Those unit vectors
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
It would be useful to learn if there are better values for these angles
 for ARISTO-2017.
\end_layout

\end_inset

 are:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\left(\begin{array}{ccc}
\cos(35) & 0 & \sin(35)\\
1 & 0 & 0\\
\cos(35) & -\sin(35)\sin(60) & -\sin(35)\cos(60)\\
\cos(35) & \sin(35)\sin(60) & -\sin(35)\cos(60)
\end{array}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<beamProcessing, echo=FALSE, include=TRUE, fig.cap=c('Airspeed measurements
 along LAMS beams for ARISTO2017 flights 1--4.
 The prediction is based on transforming the standard radome-based wind
 vector to the LAMS reference frame and then finding the projection of that
 wind along the directions of the LAMS beams.', 'Airspeed measurements along
 LAMS beams for ARISTO2017 flights 1--4.
 The prediction is based on transforming the standard radome-based wind
 vector to the LAMS reference frame and then finding the projection of that
 wind along the directions of the LAMS beams.'), cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PCA <- TRUE
\end_layout

\begin_layout Plain Layout

load('DataM.Rdata')
\end_layout

\begin_layout Plain Layout

Theta <- c(35, 0, 35, 35) * pi / 180  ## need new values for ARISTO2017
\end_layout

\begin_layout Plain Layout

Phi <- c(180, 0, 60, -60) * pi / 180
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source('chunks/processWind.R')
\end_layout

\begin_layout Plain Layout

DW <- processWind (DataM)
\end_layout

\begin_layout Plain Layout

DataM$TASL <- DW$TASX3
\end_layout

\begin_layout Plain Layout

DataM$WDL <- DW$WDN
\end_layout

\begin_layout Plain Layout

DataM$WSL <- DW$WSN
\end_layout

\begin_layout Plain Layout

DataM$WIL <- DW$WIN
\end_layout

\begin_layout Plain Layout

DataM$VXG <- DW$VXG
\end_layout

\begin_layout Plain Layout

DataM$VYG <- DW$VYG
\end_layout

\begin_layout Plain Layout

DataM$VZG <- DW$VZG
\end_layout

\begin_layout Plain Layout

# DataM$V_LOS_Beam1 <- DW$V_LOS_Beam1  ## these values have interpolation,
\end_layout

\begin_layout Plain Layout

                                       ## so don't make this substitution
\end_layout

\begin_layout Plain Layout

uv <- c(cos(Theta), -sin(Theta)*sin(Phi), -sin(Theta)*cos(Phi))
\end_layout

\begin_layout Plain Layout

dim(uv) <- c(4,3)
\end_layout

\begin_layout Plain Layout

DataM$UXA <- with(DataM, TASX / sqrt(1 + tan(ATTACK*pi/180)^2 + tan(SSRD*pi/180)
^2))
\end_layout

\begin_layout Plain Layout

RWA <- with(DataM, c(UXA, UXA*tan(ATTACK*pi/180), UXA*tan(SSRD*pi/180)))
\end_layout

\begin_layout Plain Layout

dim(RWA) <- c(nrow(DataM), 3)
\end_layout

\begin_layout Plain Layout

RWL <- XformLA(DataM, RWA)
\end_layout

\begin_layout Plain Layout

## make small adjustments to LAMS attitude angles, as indicated by LOS plots:
\end_layout

\begin_layout Plain Layout

# DataM$CPITCH_LAMS <- DataM$CPITCH_LAMS + 2
\end_layout

\begin_layout Plain Layout

# DataM$CTHDG_LAMS <- DataM$CTHDG_LAMS + 2
\end_layout

\begin_layout Plain Layout

DLAMS <- with(DataM, data.frame(Time, ROLL=CROLL_LAMS, PITCH=CPITCH_LAMS+2,
 THDG=CTHDG_LAMS+2))
\end_layout

\begin_layout Plain Layout

RWB <- XformLA(DLAMS, RWL, .inverse=TRUE)
\end_layout

\begin_layout Plain Layout

LOSV <- RWB %*% t(uv)
\end_layout

\begin_layout Plain Layout

DataM$BX1 <- LOSV[,1]
\end_layout

\begin_layout Plain Layout

DataM$BX2 <- LOSV[,2]
\end_layout

\begin_layout Plain Layout

DataM$BX3 <- LOSV[,3]
\end_layout

\begin_layout Plain Layout

DataM$BX4 <- LOSV[,4]
\end_layout

\begin_layout Plain Layout

# impose restrictions here
\end_layout

\begin_layout Plain Layout

DataR <- DataM[DataM$TASX > 90,]
\end_layout

\begin_layout Plain Layout

DataR <- DataR[abs(DataR$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

DataR <- DataR[DataR$V_LOS_Beam2_Uncertainty > 0.001 & DataR$V_LOS_Beam2_Uncertai
nty < 0.1, ]
\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol=2), widths=c(8,7), heights=c(5,5)) 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1, oma=c(1.1,0,0,0)) 
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX1, BEAM1speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement')) 
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2) 
\end_layout

\begin_layout Plain Layout

title('beam 1') 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,2,1,1)+0.1) 
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX2, BEAM2speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement')) 
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2) 
\end_layout

\begin_layout Plain Layout

title('beam 2')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX3, BEAM3speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement'))
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

title('beam 3')
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,2,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(BX4, BEAM4speed), type='p', pch=20, col='blue',
 xlab='predicted from std wind', ylab='LAMS measurement'))
\end_layout

\begin_layout Plain Layout

lines(c(-50, 300), c(-50, 300), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

title('beam 4')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results are shown in Figs.
\begin_inset space ~
\end_inset

1 and 2, after adjustments to the pitch and heading angles from the CMIGITS,
 each by 
\begin_inset Formula $+2^{\circ}$
\end_inset

.
 Without these shifts, there are obvious offsets in the cases of beams 1
 and 3.
 This suggests that the LAMS IRU may not be oriented exactly along the LAMS
 axis.
 The plot for beam 4 is based on the approach that uses Savitzky-Golay polynomia
ls
\begin_inset Foot
status open

\begin_layout Plain Layout
Analysis using the S-G polynomials produced results in good agreement with
 Matt's, but were more often missing, especially in cases where Matt assigns
 an uncertainty of more than 1 m/s.
\end_layout

\end_inset

 because Matt did not produce beam-4 LOS values.
 These have not been used in the TAS calculation and were often missing.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<plotWind, echo=FALSE, include=TRUE, fig.cap='Wind measurements from ARISTO-2017
 flight 3.
 The blue lines are from the standard wind-sensing system and the green
 lines are from LAMS.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- 3
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol = 1), widths = 1,  heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

with(DataM[DataM$RF == Flight & DataM$TASX > 50,], plotWAC(data.frame(Time,
 WDC, WDL), legend.position='bottom', ylab='WD [deg]'))  #, ylim=c(250,360))
\end_layout

\begin_layout Plain Layout

#title(fname)
\end_layout

\begin_layout Plain Layout

with(DataM[DataM$RF == Flight & DataM$TASX > 50, ], plotWAC(data.frame(Time,
 SmoothInterp(WSC), SmoothInterp(WSL)), ylim=c(0,50), legend.position='topright',
 ylab='WS [m/s]'))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(DataM[DataM$RF == Flight & DataM$TASX > 50, ], plotWAC(data.frame(Time,
 SmoothInterp(WIC), SmoothInterp(WIL)), ylim=c(-5,5), legend.position='top',
 ylab='WI [m/s]'))
\end_layout

\begin_layout Plain Layout

abline(h=0, col='darkorange', lty=2, lwd=3)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tasPlot, echo=FALSE, include=TRUE, fig.cap='Comparison of measurements
 of airspeed by the conventional system (TASX) and by the LAMS (TASL).
 Restrictions have been applied to isolate a subset of measurements expected
 to be most reliable, as discussed in the text.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol=1), widths=1, heights=6)
\end_layout

\begin_layout Plain Layout

# with(DataR, plotWAC(data.frame(Time, TASX, TASL)))
\end_layout

\begin_layout Plain Layout

with(DataR, plotWAC(data.frame(TASL, TASX),xlab='TASX [m/s]', ylab='TASL
 [m/s]', type='p', pch=20, col='blue'))
\end_layout

\begin_layout Plain Layout

lines(c(50,300), c(50,300), col='darkorange', lwd=3, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The airspeeds obtained by the LAMS and by the standard pitot-tube-based
 wind sensing system are in excellent agreement, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tasPlot}
\end_layout

\end_inset

.
 A regression fit to TASX as a linear function of TASL gives an intercept
 coefficient of -0.12 m/s and a slope coefficient of 0.9994, with a residual
 standard deviation of 0.43 m/s for 19,075 measurements from flights 1–4
 of ARISTO-2017.
 These qualifications were imposed for a measurement to be accepted in these
 plots: 
\end_layout

\begin_layout Enumerate
TASX > 90, to eliminate flight periods with possible flaps during takeoff
 and landing;
\end_layout

\begin_layout Enumerate
|roll| < 
\begin_inset Formula $3^{\circ}$
\end_inset

, to eliminate turns;
\end_layout

\begin_layout Enumerate
0.001< V_LOS_Beam2_Uncertainty < 0.1, to eliminate the points found by Matt
 Hayman's processing to have higher uncertainty, or in the case of value
 0 to be missing.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASfit, echo=TRUE, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

lfTAS <- lm(TASX ~ TASL, data=DataR)
\end_layout

\begin_layout Plain Layout

SummarizeFit(lfTAS)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Recommendation: PCor function
\end_layout

\begin_layout Standard
Because the measurements TASX and TASL agree so well, it does not seem useful
 to adjust the 
\begin_inset Quotes eld
\end_inset

PCor
\begin_inset Quotes erd
\end_inset

 function for PSF and QCF\SpecialChar endofsentence
 Instead, this check should be regarded as a test
 that the PCor correction remains appropriate, and it should be left at
 the standard formula for consistency with other projects.
\end_layout

\begin_layout Section
Study of the Pitot-Static Sensor 
\end_layout

\begin_layout Standard
New measurements were available during ARISTO-2017 from a pitot-static sensor
 designed to minimize the problems with high-frequency noise arising from
 line resonance in the standard system.
 The new variables are QCTF and PSTF, representing the dynamic and static
 (ambient) pressure.
 Because the sensor is located in a region where flow distortion around
 the aircraft is severe, the static pressure differs significantly from
 the standard measurements including PSF and PSFC\SpecialChar endofsentence
 However, the static pressure
 is not particularly useful because there is already a good measurement
 of static pressure available from the static-button ports and associated
 sensor.
 It is the measurement of dynamic pressure that is needed to improve high-freque
ncy measurements of wind.
\end_layout

\begin_layout Subsection
A proposed algorithm
\begin_inset CommandInset label
LatexCommand label
name "subsec:pitot-static-algorithm"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<compileSocratesDF, echo=FALSE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Directory <- DataDirectory()
\end_layout

\begin_layout Plain Layout

Project <- 'SOCRATES'
\end_layout

\begin_layout Plain Layout

VL <- standardVariables(c('PSTF', 'QCTF', 'PSFC', 'QCXC', 'PSF', 'QCF',
 'QCFC', 'ROLL'))
\end_layout

\begin_layout Plain Layout

Data <- data.frame()
\end_layout

\begin_layout Plain Layout

for (F in 1:7) {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(sprintf('%s%s/%srf%02d.nc', Directory, Project, Project,
 F), VL)
\end_layout

\begin_layout Plain Layout

  D <- D[D$TASX > 70 & abs(D$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

  D$RF <- F
\end_layout

\begin_layout Plain Layout

  ## eliminate some bad points at the start of rf06:
\end_layout

\begin_layout Plain Layout

  if (F == 6) {
\end_layout

\begin_layout Plain Layout

    D <- D[300:nrow(D), ]
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  Data <- rbind(Data, D)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (F in 1:2) {
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(sprintf('%s%s/%stf%02d.nc', Directory, Project, Project,
 F), VL)
\end_layout

\begin_layout Plain Layout

  D <- D[D$TASX > 70 & abs(D$ROLL) < 3, ]       
\end_layout

\begin_layout Plain Layout

  D$RF <- F+50
\end_layout

\begin_layout Plain Layout

  Data <- rbind(Data, D)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (F in 1:3) {       
\end_layout

\begin_layout Plain Layout

  D <- getNetCDF(sprintf('%s%s/%sff%02d.nc', Directory, Project, Project,
 F), VL)
\end_layout

\begin_layout Plain Layout

  D <- D[D$TASX > 70 & abs(D$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

  D$RF <- F+70
\end_layout

\begin_layout Plain Layout

  Data <- rbind(Data, D)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<totalPressure, include=TRUE, echo=FALSE, fig.cap='Total pressure measured
 by the pitot-static tube (PSTF+QCTF) vs the total pressure measured by
 the standard wind-sensing system (QCF+PSF).
 A Deming fit to these two variables gives an offset of 0.015 hPa and a slope
 coefficient of 1.000004, with a standard deviation between measurements
 of 0.14 hPa.', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$PTOT <- Data$PSF + Data$QCF
\end_layout

\begin_layout Plain Layout

Data$PTOT2 <- Data$PSTF + Data$QCTF
\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(PTOT, PTOT2), xlab='PSF+QCF [hPa]', 
\end_layout

\begin_layout Plain Layout

                    ylab='PSTF+QCTF [hPa]', type='p', pch=20))
\end_layout

\begin_layout Plain Layout

refline(300,1200)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Nevertheless, it is necessary to deal with the static-pressure measurement
 PSTF because QCTF is the difference between the measurements of total pressure
 at the stagnation point in the tube and the measured static pressure.
 The total pressure measurement is PSTF+QCTF, and it is in remarkable agreement
 with PSF+QCF, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:totalPressure}
\end_layout

\end_inset

.
 (The mean difference is 0.03 hPa; the sample standard deviation of that
 difference is 0.12.) While the pitot-static measurements could be approached
 like those of the gust-pod, seeking empirical equations that provide a
 match to QCFC, another approach is instead to subtract a smoothed version
 of the ambient pressure measured by the standard system (PSFC) from QCTF+PSTF
 to obtain QCTC.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<TASspec, include=TRUE, echo=FALSE, fig.cap='The variance spectrum for airspeed
 (TASX) for the period 4:00:00 -- 5:00:00 UTC during SOCRATES flight 1.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataT <- Data[Data$RF == 1, ]
\end_layout

\begin_layout Plain Layout

DataT <- DataT[300:nrow(DataT), ]
\end_layout

\begin_layout Plain Layout

DataT <- DataT[!is.na(DataT$Time), ]
\end_layout

\begin_layout Plain Layout

DataT <- DataT[setRange(DataT, 40000, 50000),]
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataT, 'TASX', VLabel='Airspeed (TASX) [m/s]', method='MEM')
\end_layout

\begin_layout Plain Layout

print(g + theme_WAC())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<PSFspec, include=TRUE, echo=FALSE, fig.cap='Variance spectra for QCF and
 PSF for the same period as in the previous plot.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- VSpec(DataT, 'QCF', method='MEM')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataT, 'PSF', col='forestgreen', method='MEM', ADD=g)
\end_layout

\begin_layout Plain Layout

print(g + theme_WAC())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It is useful to consider first the characteristics of the standard measurements
 of ambient, dynamic and total pressure.
 An example is a region with moderately low turbulence, 4:00:00–5:00:00
 UTC on SOCRATES flight 1, which is characterized at high frequency by an
 eddy dissipation rate of about 
\begin_inset Formula $10^{-5}\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.
 The spectral variance for the airspeed measurement is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:TASspec}
\end_layout

\end_inset

, and at low rate there are no evident problems.
 The corresponding plot for dynamic pressure (QCF or QCFC) looks similarly
 good.
 In contrast, the plot for the variable PSF has much lower amplitude, as
 shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:PSFspec}
\end_layout

\end_inset

, and shows a clear noise floor corresponding to that expected for a random
 error of about 0.15 hPa.
 This matches the quoted uncertainty for the transducer (see 
\begin_inset Quotes eld
\end_inset

accuracy
\begin_inset Quotes erd
\end_inset

 at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://www.eol.ucar.edu/system/files/inttransmitters.pdf"

\end_inset

).
 For measurements at frequencies above about 0.1 Hz, the measurement PSF
 is dominated by noise and does not provide useful information.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<PTOTspectra, include=TRUE, echo=FALSE, fig.cap='Measurements of total pressure
 (ambient plus dynamic) from the standard system and from the new pitot-static
 system.
 Data from SOCRATES flight 
\backslash

\backslash
#1, 4:00:00--5:00:00 UTC.', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'SOCRATES'
\end_layout

\begin_layout Plain Layout

VL <- standardVariables(c('PSTF', 'QCTF', 'PSFC', 'QCXC', 'PSF', 'QCF',
 'QCFC', 'ROLL'))
\end_layout

\begin_layout Plain Layout

DataHR <- getNetCDF(sprintf('%s%s/%srf01_hr.nc', Directory, Project, Project),
 VL, Start=40000, End=50000)
\end_layout

\begin_layout Plain Layout

DataHR$PTOT <- DataHR$PSF + DataHR$QCF
\end_layout

\begin_layout Plain Layout

DataHR$PTOT2 <- DataHR$PSTF + DataHR$QCTF
\end_layout

\begin_layout Plain Layout

DataHR$PTOTD <- removeSpikes(DataHR$PTOT2, sdLimit=2)  ## very aggressive
 limit
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataHR, 'PTOT', VLabel='total p, std', method='MEM')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataHR, 'PTOT2', VLabel='total p, new', method='MEM', ADD=g)
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataHR, 'PTOTD', VLabel='total p, new, despiked', method='MEM',
 ADD=g)
\end_layout

\begin_layout Plain Layout

print(g + theme_WAC())
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Although the total pressure measurements from the standard and the pitot-static
 sensors agree well for 1-Hz measurements, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:totalPressure}
\end_layout

\end_inset

, the two differ significantly in high-frequency response, as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:PTOTspectra}
\end_layout

\end_inset

, because there is much more noise in the standard measurements.
 The pitot-static sensor did not show a similar increase proportional to
 frequency, as expected for random noise, but it did show some apparent
 flattening in the frequency range above about 4_Hz.
 Both the standard and pitot-static measurements have some apparently spurious
 spikes in the time period used, but an aggressive elimination of possible
 spikes lowered the spectrum for the pitot-static sensor (red line in the
 plot) but did not remove the flattening.
 Similarly, elimination of spikes
\begin_inset Foot
status open

\begin_layout Plain Layout
The method used was to calculate the running mean and standard deviation
 of the variable, then remove measurements that differed more than two standard
 deviations from the mean and replace them with interpolated values.
 The usual test is five standard deviations, but using two is the 
\begin_inset Quotes eld
\end_inset

aggressive
\begin_inset Quotes erd
\end_inset

 test used here only for this purpose.
\end_layout

\end_inset

 in the standard total-pressure measurement only lowered the noise spectrum
 slightly (by about 25%) but did not remove the strong evidence of noise
 in this measurement.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<PSFF, include=TRUE, echo=FALSE, fig.cap='Filtered and unfiltered measurements
 of ambient pressure (PSFC) for SOCRATES Flight 1, 4:30:00 -- 5:00:00 UTC.
 (Spectra are smoothed in 100 logarithmically spaced bins.)', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- getNetCDF(sprintf('%s%s/%srf01_hr.nc', Directory, Project, Project),
\end_layout

\begin_layout Plain Layout

                VL, Start=42000, End=51000)  ## include extra segments
\end_layout

\begin_layout Plain Layout

DT$PSFF <- signal::filtfilt (signal::butter (3, 2/(2*25), type='low'), DT$PSFC)
\end_layout

\begin_layout Plain Layout

DT$PTOT2 <- DT$PSTF + DT$QCTF
\end_layout

\begin_layout Plain Layout

DX <- DT[setRange(DT, 43000, 50000), ]
\end_layout

\begin_layout Plain Layout

g <- VSpec(DX, 'PSFC', smoothBins=100)
\end_layout

\begin_layout Plain Layout

g <- VSpec(DX, 'PSFF', VLabel='filtered PSFC', smoothBins=100, ADD=g)
\end_layout

\begin_layout Plain Layout

VSpec(DX, 'PTOT2', VLabel='total pressure, p-s sensor', col='black', smoothBins=
100, ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The point of this digression into the individual variance spectra is that,
 for the method proposed, subtracting the standard pressure PSFC from the
 total pressure from the pitot-static tube will contaminate the result by
 inclusion of the noise in PSFC\SpecialChar endofsentence
 Therefore, filtering to remove that noise
 is needed.
 A review of the 25-Hz data from SOCRATES Flight #1 indicated that PSF consisten
tly exhibits a noise spectrum for frequencies above about 0.3 Hz, so a reasonably
 sharp low-pass filter with that frequency cutoff should eliminate little
 real signal while removing the contaminating noise.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:PSFF}
\end_layout

\end_inset

 shows the result of filtering along with the unfiltered variable PSFC and
 the total pressure measurement from the pitot-static sensor (black line).
 The true signal present in PSFC is very small at the cutoff frequency (0.5
\begin_inset space ~
\end_inset

Hz), so nothing but noise is lost by using the filtered variable.
 Without such filtering, the variable PSFC would contaminate the derived
 dynamic pressure from the pitot-static sensor (here, QCTC) if it were to
 be calculated from QCTC=QCTF+PSTF-PSFC, although this could be used for
 low-rate measurements.
 At high rate (25
\begin_inset space ~
\end_inset

Hz), the following should be used: QCTC=QCTF+PSTF-PSFF where PSFF is the
 result of a low-pass filter applied to PSFC.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ResultQCTC, include=TRUE, echo=FALSE, fig.cap='Variance spectrum for the
 variable QCTC, the corrected dynamic pressure from the pitot-static sensor.
 Also shown in the corresponding spectrum from the standard measurement
 (QCFC).
 The data are from 4:00:00 -- 5:00:00 on SOCRATES Flight 1.', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DX$QCTC <- DX$QCTF + DX$PSTF - DX$PSFF
\end_layout

\begin_layout Plain Layout

g <- VSpec(DX, 'QCTC', method='MEM')
\end_layout

\begin_layout Plain Layout

VSpec(DX, 'QCFC', method='MEM', ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The variance spectrum for the resulting dynamic pressure from the pitot-static
 tube is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ResultQCTC}
\end_layout

\end_inset

 as the variable QCTC\SpecialChar endofsentence
 Also shown is the standard measurement from the radome-bas
ed system (QCFC) after all corrections (often called PCors) have been applied.
 No such correction is needed for QCTC because the appropriate corrections
 have already been applied to PSFC before it is used to calculate QCTC.
 The high-frequency portion of the new spectrum is much better than the
 standard one, but it still shows some probably spurious flattening beyond
 about 3
\begin_inset space ~
\end_inset

Hz.
 There are easily identified spikes in the high-rate time series being used,
 but the spike-removal algorithm did not remove this plateau.
 It is important to correct the cause of the spikes, though, because there
 may also be smaller ones not identified by the spike-removal algorithm
 that nevertheless may contaminate the high-rate variance spectrum.
\end_layout

\begin_layout Standard
Further discussion of the consequences for measurements of wind components
 will be deferred to a later section so that the gust-pod measurements can
 be discussed first and then all can be compared.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<QCTC, include=TRUE, echo=FALSE, fig.cap='The variables QCTC (new variable,
 corrected, from the pitot-static sensor) and QCFC, the standard variable,
 for SOCRATES test flight 4.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

PSFCF <- SmoothInterp (Data$PSFC, .Length=0)  ## just interpolate
\end_layout

\begin_layout Plain Layout

Data$PSFCF <- signal::filtfilt (signal::butter (3, 2/10), PSFCF)
\end_layout

\begin_layout Plain Layout

Data$QCTC <- with(Data, QCTF+PSTF-PSFCF)
\end_layout

\begin_layout Plain Layout

DataT <- Data[Data$RF == 1, ]  ## a temporary working data.frame
\end_layout

\begin_layout Plain Layout

DataT <- DataT[300:nrow(DataT), ]  ## remove some bad initial points
\end_layout

\begin_layout Plain Layout

DataT <- DataT[!is.na(DataT$Time), ]  ## remove some missing-time points
\end_layout

\begin_layout Plain Layout

with(DataT, plotWAC(data.frame(Time, QCTC, QCFC), ylab='QC corrected [hPa]'))
\end_layout

\begin_layout Plain Layout

## There are 26 points, out of 120,238, where the difference is > 1.
 Eliminate them:
\end_layout

\begin_layout Plain Layout

Data$QCTC[abs(Data$QCTC-Data$QCFC) > 1] <- NA
\end_layout

\begin_layout Plain Layout

meanQCDIF <- with(Data[Data$TASX > 90, ], mean(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdQCDIF <- with(Data[DataS$TASX > 90, ], sd(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The resulting variable QCTC is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:QCTC}
\end_layout

\end_inset

 along with the standard corrected variable QCFC\SpecialChar endofsentence
 The variables are essentially
 overlapping: The mean difference for the flight shown is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(meanQCDIF, 2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

hPa and the standard deviation of the difference is 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sdQCDIF,2)}
\end_layout

\end_inset


\begin_inset space ~
\end_inset

hPa, so this approach provides a good match to QCFC for 1-Hz measurements.
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<PStubeVarSpec, include=TRUE, echo=FALSE, fig.cap='Comparison of the corrected
 dynamic-pressure measurements QCFC (from the standard calculations) and
 QCTC (from the new calculation for the pitot-static sensor).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Vars <- c('ATTACK', 'SSLIP', 'GGVEW', 'GGVNS', 'GGVSPD', 'VEW', 'VNS', 'PITCH',
 'ROLL', 'THDG', 'UXC', 'VYC')
\end_layout

\begin_layout Plain Layout

DataS <- getNetCDF('/Data/SOCRATES/SOCRATESrf01HRT.nc', standardVariables(c(Vars,
 'QCFC', 'QCTF', 'PSTF', 'PSF', 'QCF', 'PSFC')), Start=22500, End=23100)
\end_layout

\begin_layout Plain Layout

Rate <- 25
\end_layout

\begin_layout Plain Layout

PSFCF <- SmoothInterp (DataS$PSFC, .Length=0)  ## just interpolate
\end_layout

\begin_layout Plain Layout

DataS$PSFCF <- signal::filtfilt (signal::butter (3, 2/(10*Rate)), PSFCF)
\end_layout

\begin_layout Plain Layout

DataS$QCTC <- with(DataS, QCTF+PSTF-PSFCF)
\end_layout

\begin_layout Plain Layout

# with(DataS[DataS$TASX > 90, ], plotWAC(data.frame(Time, QCTC, QCFC), ylab='QC
 corrected [hPa]'))
\end_layout

\begin_layout Plain Layout

meanQCDIF <- with(DataS[DataS$TASX > 90, ], mean(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

sdQCDIF <- with(DataS[DataS$TASX > 90, ], sd(QCTC-QCFC, na.rm=TRUE))
\end_layout

\begin_layout Plain Layout

DataS <- DataS[setRange(DataS, 22520, 23040),]
\end_layout

\begin_layout Plain Layout

spans <- 49
\end_layout

\begin_layout Plain Layout

S <- spectrum (ts(DataS$QCTC, frequency=Rate), span=spans, plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq <- S$freq
\end_layout

\begin_layout Plain Layout

fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

S2 <- spectrum(ts(DataS$QCFC, frequency=Rate), span=spans, plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq2 <- S2$freq
\end_layout

\begin_layout Plain Layout

fpf2 <- 2 * S2$spec * freq2
\end_layout

\begin_layout Plain Layout

labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

laby <- 'fP(f) for corrected QC'
\end_layout

\begin_layout Plain Layout

xlim <- c(0.001,15)
\end_layout

\begin_layout Plain Layout

ylim <- c(0.001, 1) 
\end_layout

\begin_layout Plain Layout

DF1 <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

DF2 <- data.frame(freq2, fpf2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(data=DF1)         
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq, y=fpf, colour='QCTC'), na.rm=TRUE) +    
       xlab(labx) + ylab (laby) 
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq2, y=fpf2, colour='QCFC'), data=DF2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

cLines <- c('blue', 'forestgreen')
\end_layout

\begin_layout Plain Layout

names(cLines) <- c('QCFC', 'QCTC')
\end_layout

\begin_layout Plain Layout

g <- g + (scale_colour_manual (name='', values=cLines))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

  labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  scale_y_log10(breaks =            trans_breaks("log10", function(x) 10^x,
 n=4), #limits = ylim,             
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  coord_cartesian(xlim=xlim, ylim=ylim) 
\end_layout

\begin_layout Plain Layout

tasAverage <- mean(DataS$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

ae <- 0.2
\end_layout

\begin_layout Plain Layout

for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

  a = ae * 10.^(i*(2/3)) * tasAverage^(2/3)
\end_layout

\begin_layout Plain Layout

  lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

  DFL <- data.frame(x=xlim, y=c(a/xlim[1]^(2/3), a/xlim[2]^(2/3)))
\end_layout

\begin_layout Plain Layout

  # print(DFL)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path (data=DFL, aes(x=x, y=y), colour='darkorange', lwd=lw,
 lty=3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- g + theme_WAC()
\end_layout

\begin_layout Plain Layout

print(g)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newWind, include=TRUE, echo=FALSE, fig.cap=' '>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## set up a data.frame for calculating the new wind:
\end_layout

\begin_layout Plain Layout

D <- DataS
\end_layout

\begin_layout Plain Layout

D$QCXC <- DataS$QCTC
\end_layout

\begin_layout Plain Layout

## find new TAS
\end_layout

\begin_layout Plain Layout

TASPT <- TrueAirspeed(MachNumber(DataS$PSFCF, DataS$QCTC, DataS$EWX), DataS$ATX,
 DataS$EWX / DataS$PSFCF)
\end_layout

\begin_layout Plain Layout

D$TASX <- TASPT
\end_layout

\begin_layout Plain Layout

DW <- WindProcessor(D, CompF=FALSE)
\end_layout

\begin_layout Plain Layout

hdg <- DataS$THDG * pi/180
\end_layout

\begin_layout Plain Layout

wd <- DW$WDN * pi/180 + pi
\end_layout

\begin_layout Plain Layout

DataS$UXPT <- DW$WSN * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

hdg <- hdg - pi/2
\end_layout

\begin_layout Plain Layout

DataS$VYPT <- DW$WSN * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

DataS$WDN <- DW$WDN
\end_layout

\begin_layout Plain Layout

DataS$WSN <- DW$WSN
\end_layout

\begin_layout Plain Layout

DataS$WIN <- DW$WIN
\end_layout

\begin_layout Plain Layout

DataS$TASPT <- DW$TASX
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:PStubeVarSpec}
\end_layout

\end_inset

 shows variance spectra from the low-level leg from SOCRATES flight #1,
 2:25:20–2:30:40 UTC\SpecialChar endofsentence
 The high-frequency noise is reduced significantly but
 is still present in QCTC, although the level of turbulence is relatively
 low so a noise floor might be expected.
 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VSpec1, include=TRUE, echo=FALSE, fig.cap='Variance spectra for the measurement
s of vertical wind using the standard method (WIC) and the new pitot-static
 tube (WIN).
 Data from SOCRATES flight 1, 2:25:20--2:30:40.' >>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

spans <- 49
\end_layout

\begin_layout Plain Layout

Rate <- 25
\end_layout

\begin_layout Plain Layout

n1 <- 'WIC'
\end_layout

\begin_layout Plain Layout

n2 <- 'WIN'
\end_layout

\begin_layout Plain Layout

ae <- 0.2  ## use 0.15 for longitudinal spectra
\end_layout

\begin_layout Plain Layout

PlotVSpec <- function (n1, n2, DataS) {
\end_layout

\begin_layout Plain Layout

v1 <- DataS[, n1]
\end_layout

\begin_layout Plain Layout

v2 <- DataS[, n2]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

S <- spectrum (ts(SmoothInterp(v1, .Length=0), frequency=Rate), span=spans,
 plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq <- S$freq
\end_layout

\begin_layout Plain Layout

fpf <- 2 * S$spec * freq
\end_layout

\begin_layout Plain Layout

S2 <- spectrum(ts(SmoothInterp(v2, .Length=0), frequency=Rate), span=spans,
 plot=FALSE)
\end_layout

\begin_layout Plain Layout

freq2 <- S2$freq
\end_layout

\begin_layout Plain Layout

fpf2 <- 2 * S2$spec * freq2
\end_layout

\begin_layout Plain Layout

labx <- 'frequency [Hz]'
\end_layout

\begin_layout Plain Layout

laby <- 'fP(f)'
\end_layout

\begin_layout Plain Layout

xlim <- c(0.001,15)
\end_layout

\begin_layout Plain Layout

ylim <- c(0.001, 1) 
\end_layout

\begin_layout Plain Layout

DF1 <- data.frame(freq, fpf)
\end_layout

\begin_layout Plain Layout

DF2 <- data.frame(freq2, fpf2)
\end_layout

\begin_layout Plain Layout

g <- ggplot(data=DF1)         
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq, y=fpf, colour=n1), na.rm=TRUE) +        
   xlab(labx) + ylab (laby) 
\end_layout

\begin_layout Plain Layout

g <- g + geom_path (aes(x=freq2, y=fpf2, colour=n2), data=DF2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

cLines <- c('blue', 'forestgreen')
\end_layout

\begin_layout Plain Layout

names(cLines) <- c(n1, n2)
\end_layout

\begin_layout Plain Layout

g <- g + (scale_colour_manual (name='', values=cLines))
\end_layout

\begin_layout Plain Layout

g <- g + scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x,
 n=4), #limits = xlim, 
\end_layout

\begin_layout Plain Layout

  labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  scale_y_log10(breaks =            trans_breaks("log10", function(x) 10^x,
 n=4), #limits = ylim,             
\end_layout

\begin_layout Plain Layout

    labels = trans_format("log10", math_format(10^.x))) +           
\end_layout

\begin_layout Plain Layout

  coord_cartesian(xlim=xlim, ylim=ylim) 
\end_layout

\begin_layout Plain Layout

tasAverage <- mean(DataS$TASX, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

for (i in (-8:0)) {
\end_layout

\begin_layout Plain Layout

  a = ae * 10.^(i*(2/3)) * tasAverage^(2/3)
\end_layout

\begin_layout Plain Layout

  lw = ifelse(i == -4, 1.2, 0.5)
\end_layout

\begin_layout Plain Layout

  DFL <- data.frame(x=xlim, y=c(a/xlim[1]^(2/3), a/xlim[2]^(2/3)))
\end_layout

\begin_layout Plain Layout

  # print(DFL)
\end_layout

\begin_layout Plain Layout

  g <- g + geom_path (data=DFL, aes(x=x, y=y), colour='darkorange', lwd=lw,
 lty=3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

return(g + theme_WAC())
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

print (PlotVSpec(n1, n2, DataS))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VSpec2, include=TRUE, echo=FALSE, fig.cap='Variance spectra for measurements
 of the longitudinal component of the wind, UXC (standard measurement) and
 UXPT (measurement based on the pitot-static tube).
 Data from the same flight segment as for the previous figure.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

n1 <- 'UXC'
\end_layout

\begin_layout Plain Layout

n2 <- 'UXPT'
\end_layout

\begin_layout Plain Layout

ae <- 0.15
\end_layout

\begin_layout Plain Layout

print (PlotVSpec(n1, n2, DataS))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
To see the effect on the wind spectra, winds were recalculated using the
 new value for dynamic pressure.
 The airspeed was calculated in standard ways (including humidity correction
 terms.
 For details and the Ranadu functions involved, see the R code embedded
 with this document.
 For the transverse components of the wind (WIC and VYC), the new results
 essentially duplicated the standard ones, as illustrated in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VSpec1}
\end_layout

\end_inset

.
 The spectrum for the other lateral component (VYC in standard processing)
 showed similar agreement; the plotted spectra were essentially the same.
 For the problematic lateral component, however, the pitot-static tube provided
 significant improvement but still showed evidence of noise at the highest
 frequency.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VSpec2}
\end_layout

\end_inset

 shows significant improvement in comparison to the standard measurement,
 but there is still evidence of noise for the portion of the spectrum above
 about 5_Hz.
 The magnitude of the noise is approximately that expected for a measurement
 precision of 0.2
\begin_inset space ~
\end_inset

m/s, From error propagation using 
\begin_inset Formula $q=0.5\rho v^{2}$
\end_inset

, a relative error in 
\begin_inset Formula $v$
\end_inset

 of about 0.1% would give a relative error in 
\begin_inset Formula $q$
\end_inset

 of 0.2% or about 0.2 hPa in low-level flight.
 This is significantly above the precision expected from the sensor, so
 it isn't clear why the level of noise is as high as it is.
 (I don't have specs for this specific sensor; need to get that to complete
 this argument, which now is based on similar transducers.) In other flight
 segments, the noise level is significantly lower.
\begin_inset Foot
status open

\begin_layout Plain Layout
The analysis of this flight is complicated by the frequent very large spikes
 in high-rate QCF that introduce a high level of noise in that spectrum.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Conclusion Regarding the Pitot-Static Sensor
\end_layout

\begin_layout Plain Layout
A processing scheme was developed that duplicates the standard measurement
 of dynamic pressure at low frequency.
 At high frequency, there is significant reduction in the noise in the longitudi
nal component of the wind and in measured airspeed when the pitot-static
 sensor is used, but the variance spectra (esp.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VSpec2}
\end_layout

\end_inset

) still show evidence of high-frequency noise.
 I don't understand the remaining source of noise, which appears to be more
 than just random error in the transducer and varies in different flight
 situations.
 More study is needed to arrive at a method of calculating wind using this
 sensor, but it has provided a significant improvement.
\end_layout

\begin_layout Plain Layout
The particular method used here is suited best to second-pass processing.
 A revision to the low-pass filter that uses a recursive filter could be
 implemented, but the effect of this (vs.
\begin_inset space ~
\end_inset

the centered filter used here) needs to be investigated.
\end_layout

\begin_layout Plain Layout
The gust pod provides very useful measurements at 1 Hz, as documented in
 another note.
 The high-frequency spectrum from the gust pod was found in DEEPWAVE to
 be less subject to noise than the radome-based system, so investigating
 the high-rate behavior of that system is still a promising route to possible
 improvement in the wind measurements.
 The pitot-static tube has not solved the problem of noise in the high-rate
 variance spectra, although it provides a significant improvement.
\end_layout

\end_inset


\end_layout

\begin_layout Section
Using the Gust Pod in SOCRATES
\end_layout

\begin_layout Standard
Simple extension of the DEEPWAVE approach to the gust pod did not work well,
 so a different approach is developed in this note.
 The key problem arises from the gust-pod measurement of the relative wind,
 because the quantity needed is the relative wind with respect to the aircraft,
 not the gust pod.
 The gust pod is located in a region of distorted airflow where the sideslip
 and angle-of-attack components may affect each other, the pod is not oriented
 along the aircraft axis and may move relative to the fuselage.
 The wind is measured by combining the measurement of relative wind vector,
 transformed to a reference frame fixed relative to the Earth, with the
 measurement of the aircraft velocity vector.
 With the inclusion of the large pod in SOCRATES, the airflow distortion
 has become more problematic.
\end_layout

\begin_layout Subsection
The general approach
\end_layout

\begin_layout Standard
The CMIGITS INS used by the gust pod performs well and provides appropriate
 measurements of the gust-pod motion relative to the Earth to use when calculati
ng the wind.
 Small corrections required when the pitch or roll angles change, leading
 to motion of the gust pod relative to the aircraft reference frame, initially
 will be ignored.
 The differences in aircraft-velocity components between the two systems
 are typically quite small: For SOCRATEStf01, the mean difference between
 velocity components was 0.0005
\begin_inset Formula $\pm0.05$
\end_inset


\begin_inset space ~
\end_inset

m/s (sample standard deviation) for the easterly component and 
\begin_inset Formula $-0.0002\pm0.06$
\end_inset


\begin_inset space ~
\end_inset

m/s for the northerly component.
 Most of the listed sample standard deviation was contributed by periods
 when the roll angle was outside 
\begin_inset Formula $\pm3^{\circ}$
\end_inset

; within those limits, the sample standard deviation for 1-Hz measurements
 was about 0.025
\begin_inset space ~
\end_inset

m/s.
 Therefore, for the purpose of the present analysis, no transformation or
 correction to the CMIGITS-provided measurements of aircraft velocity is
 needed except for the omitted compensation for the motion of the gust pod
 relative to the Honeywell INS.
 The gust pod is located 13 m behind the INS, 7 m to the port side, and
 within about 1 m vertically.
 However, the GPS antenna that the CMIGITS INS uses is at the same location
 as that used by standard wind processing, so the CMIGITS aircraft-velocity
 components are updated to that reference point.
 Mean updated measurements of ground-speed components should therefore agree.
\end_layout

\begin_layout Standard
These steps then are involved in the new processing scheme:
\end_layout

\begin_layout Enumerate
Define a new reference frame, here called the g-frame.
 Three reference frames then are used here: the a-frame (defined with 
\begin_inset Formula $\hat{x}$
\end_inset

 forward along the longitudinal axis of the aircraft, 
\begin_inset Formula $\hat{y}$
\end_inset

 to starboard and perpendicular to 
\begin_inset Formula $\hat{x}$
\end_inset

, and 
\begin_inset Formula $\hat{z}$
\end_inset

 determined by the cross product of 
\begin_inset Formula $\hat{x}$
\end_inset

 and 
\begin_inset Formula $\hat{y}$
\end_inset

 but generally downward); the g-frame (defined analogously but with reference
 to the gust-pod orientation which is slightly different from the aircraft
 reference frame); and the l-frame (the local Earth-relative frame with
 
\begin_inset Formula $\hat{x}$
\end_inset

 eastward, 
\begin_inset Formula $\hat{y}$
\end_inset

 northward, and 
\begin_inset Formula $\hat{z}$
\end_inset

 upward).
 Transformation among these reference frames was described in the 
\begin_inset CommandInset href
LatexCommand href
name "Workflow Document for the Kalman Filter Technical Note"
target "https://drive.google.com/open?id=1mB-nwvaAw113nr1_2RRtIODxDj7h9W5X"

\end_inset

.
 Because the CMIGITS IRU aligns with some residual error that is gradually
 corrected in flight by Kalman-filter updating, and because there is some
 motion of the wings in turbulence and as the aircraft fuel weight decreases,
 the difference in orientation between the two systems (Honeywell and CMIGITS)
 may change during the flight, so it is necessary to consider the attitude-angle
 transformation each time interval during processing rather than via a constant
 correction for the entire flight.
\end_layout

\begin_layout Enumerate
Estimate the relative-wind components in the a-frame using gust-pod measurements
 in the g-frame.
 In the g-frame, the relative wind that would be measured is distorted unaccepta
bly from the true relative wind outside the flow-distortion field of the
 aircraft, so the solution is not to simply transform the measured relative-wind
 vector from the g-frame to the l-frame.
 Instead, the approach here is as follows:
\end_layout

\begin_deeper
\begin_layout Enumerate
Consider the two differential-pressure measurements from the up-down and
 left-right pairs of ports on the gust pod as a two-component vector measurement
 representing the pressure difference at the gust pod.
 Make the trial assumption that the ports align with the axes defined by
 the CMIGITS INS\SpecialChar endofsentence
 Transform this pressure-gradient vector from the g-frame
 to the a-frame, where it is resolved into 
\begin_inset Formula $\hat{x}_{a}$
\end_inset

 and 
\begin_inset Formula $\hat{y}_{a}$
\end_inset

 components.
 
\end_layout

\begin_layout Enumerate
Find the best representation of the a-frame relative wind (approximately
 {
\begin_inset Formula $V,\,V\beta,\,V\alpha$
\end_inset

} with 
\begin_inset Formula $V$
\end_inset

 the airspeed,
\begin_inset Formula $\beta$
\end_inset

 the sideslip angle and 
\begin_inset Formula $\alpha$
\end_inset

 the angle of attack) [XXX correct the signs] by a fit to the normal a-frame
 relative wind as a function of standard measurements and the transformed
 pressure-gradient components.
 This will give a relative-wind vector analogous to the one from the standard
 wind-sensing system but potentially independent of the radome pressure
 measurements that are sometimes affected by line freezing or contamination
 in the lines.
 This preserves the backup potential of the gust pod.
 
\end_layout

\begin_layout Enumerate
It is also desirable to produce an airspeed measurement from the gust pod
 (TASG) that is independent of the standard system, but it is probably best
 to use TASX to calculate the relative wind because it is expected to be
 the best available measurement of airspeed in the a-frame.
 The 
\begin_inset Quotes eld
\end_inset

PCor
\begin_inset Quotes erd
\end_inset

 function used to adjust the airspeed measurement for the static defect
 depends on a valid measurement of angle of attack, but in a relatively
 insensitive way, and normal processing substitutes an average value when
 no valid measurement of AKRD is available.
 TASG might provide a valuable backup in that case.
\end_layout

\end_deeper
\begin_layout Standard
When the aircraft rolls about its longitudinal axis, complicated changes
 occur to the CMIGITS attitude angles.
 A pure roll change in the a-frame can change all three attitude angles
 in the g-frame because the gust-pod longitudinal axis is not aligned along
 the aircraft longitudinal axis.
 The angle transformations must account for this or the relative-wind measuremen
ts will not be valid for general orientations of the aircraft.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<get-data, include=FALSE, echo=FALSE, fig.cap='', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## combine SOCRATES tf01, ff03, and rf01 for this analysis
\end_layout

\begin_layout Plain Layout

Flight <- "tf01"  
\end_layout

\begin_layout Plain Layout

Project <- "SOCRATES"
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

# SOCRATES files use GGVSPD, have EWX, and have ADIF_GP and BDIF_GP
\end_layout

\begin_layout Plain Layout

VarNames <- c("VYC","GGALT","LATC", "LONC", "PSXC", "QCXC",
\end_layout

\begin_layout Plain Layout

              "WDC", "WSC", "GGVEW", "GGVNS", "VEW", "VNS",
\end_layout

\begin_layout Plain Layout

              "QCTF", "PSTF",
\end_layout

\begin_layout Plain Layout

              "ADIFR", "ATTACK", "SSLIP", "PITCH", "TASX",
\end_layout

\begin_layout Plain Layout

              "ROLL", "THDG", "BDIFR", "GGVSPD", 'EWX',
\end_layout

\begin_layout Plain Layout

              "ADIF_GP", "BDIF_GP", "PS_GP", "QC_GP",
\end_layout

\begin_layout Plain Layout

              "CROLL_GP", "CPITCH_GP", "CTHDG_GP", "WIC",
\end_layout

\begin_layout Plain Layout

              "CVNS_GP", "CVEW_GP", "VSPD", "CVSPD_GP",
\end_layout

\begin_layout Plain Layout

              "ATX", 'SSRD', 'AKRD', 'QCF', 'PSF')
\end_layout

\begin_layout Plain Layout

D <- getNetCDF (fname, VarNames, F=51)
\end_layout

\begin_layout Plain Layout

ix <- which(D$TASX > 60)
\end_layout

\begin_layout Plain Layout

D <- D[ix[1]:ix[length(ix)], ]
\end_layout

\begin_layout Plain Layout

## remove 15 min at start and end
\end_layout

\begin_layout Plain Layout

# D <- D[901:(nrow(D)-901), ]
\end_layout

\begin_layout Plain Layout

Flight <- 'ff02'
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

DD <- getNetCDF (fname, VarNames, F=72)
\end_layout

\begin_layout Plain Layout

ix <- which(DD$TASX > 60)
\end_layout

\begin_layout Plain Layout

DD <- DD[ix[1]:ix[length(ix)], ]
\end_layout

\begin_layout Plain Layout

# DD <- DD[901:(nrow(DD)-901), ]
\end_layout

\begin_layout Plain Layout

D <- rbind(D, DD)
\end_layout

\begin_layout Plain Layout

Flight <- 'rf01'
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

DD <- getNetCDF (fname, VarNames, F=1)
\end_layout

\begin_layout Plain Layout

## in rf01, gust pod problems 33000--35000
\end_layout

\begin_layout Plain Layout

rbad <- setRange(DD, 32500, 35000)
\end_layout

\begin_layout Plain Layout

DD$QC_GP[rbad] <- NA
\end_layout

\begin_layout Plain Layout

## wait until later to remove from the fit data.frame (DataF)
\end_layout

\begin_layout Plain Layout

ix <- which(DD$TASX > 60)
\end_layout

\begin_layout Plain Layout

DD <- DD[ix[1]:ix[length(ix)], ]
\end_layout

\begin_layout Plain Layout

# DD <- DD[901:(nrow(DD)-901), ]
\end_layout

\begin_layout Plain Layout

D <- rbind(D, DD)
\end_layout

\begin_layout Plain Layout

## add some variables needed for the AOA complementary-filter
\end_layout

\begin_layout Plain Layout

D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

    D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

    D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

    D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

    D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

    CutoffPeriod <- 600
\end_layout

\begin_layout Plain Layout

    Rate <- 1
\end_layout

\begin_layout Plain Layout

    D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

    D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

    D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

    D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

    D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

    D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

    D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

Data <- D
\end_layout

\begin_layout Plain Layout

Cradeg <- pi / 180.
\end_layout

\begin_layout Plain Layout

## this is the speed run from tf01:  [works because tf01 is first file)
\end_layout

\begin_layout Plain Layout

r5 <- setRange (Data, 221035, 221510)
\end_layout

\begin_layout Plain Layout

# r1 <- setRange (Data, 192609, 193328)
\end_layout

\begin_layout Plain Layout

# r2 <- setRange (Data, 195540, 200222)
\end_layout

\begin_layout Plain Layout

# r3 <- setRange (Data, 205058, 205604)
\end_layout

\begin_layout Plain Layout

# r4 <- setRange (Data, 210402, 211234)
\end_layout

\begin_layout Plain Layout

# Data2 <- Data[c(r1,r2,r3,r4),]
\end_layout

\begin_layout Plain Layout

Data2 <- Data[r5, ]
\end_layout

\begin_layout Plain Layout

Data2 <- Data2[abs(Data2$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

r6 <- setRange(Data, 221600, 221830)
\end_layout

\begin_layout Plain Layout

Data3 <- Data[r6, ]
\end_layout

\begin_layout Plain Layout

capnFaoaG <- "For the gust pod, the angle-of-attack determined from the
 fit as a function of the reference angle provided by (
\backslash

\backslash
ref{eq:AOAeq}), for the speed run on SOCRATES tf01.
 The dashed orange line is the fit to the measurements, and the thinner
 solid black line is the result from the coefficients determined in DEEPWAVE."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Details of the Transformation
\end_layout

\begin_layout Standard
The vector to be transformed has components (0, BDIF_GP, ADIF_GP) in the
 g-frame.
 Because in the R package 
\begin_inset Quotes eld
\end_inset

Ranadu
\begin_inset Quotes erd
\end_inset

 [
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"

\end_inset

] there is a transformation function (XformLA) that transforms from the
 a-frame to the l-frame or the l-frame to the a-frame, that will be used
 here because that transformation function was tested extensively during
 the development of the Kalman filter.
 Details are described in the 
\begin_inset CommandInset href
LatexCommand href
name "workflow document"
target "https://github.com/WilliamCooper/KalmanFilter/blob/master/WorkflowKalmanFilter.pdf"

\end_inset

 for the Kalman filter Technical Note (
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2017ncartn"

\end_inset

).
 The procedure is to transform the pressure vector from the g-frame to the
 l-frame using the CMIGITS-provided attitude angles, then transform from
 the l-frame to the a-frame using the Honeywell-provided attitude angles
 and the inverse function in XformLA().
 The code listed below produces, in diffPa, the matrix of measured pressure
 differences transformed to the a-frame:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<xform, echo=TRUE, include=TRUE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

diffP <- c(rep(0, nrow(Data)), Data$BDIF_GP, Data$ADIF_GP)  ## check signs!!
\end_layout

\begin_layout Plain Layout

dim(diffP) <- c(nrow(Data), 3)
\end_layout

\begin_layout Plain Layout

DF <- data.frame(ROLL=Data$CROLL_GP, PITCH=Data$CPITCH_GP, THDG=Data$CTHDG_GP)
\end_layout

\begin_layout Plain Layout

diffPl <- Ranadu::XformLA (DF, diffP)  ## DF contains gustpod attitude angles
\end_layout

\begin_layout Plain Layout

diffPa <- Ranadu::XformLA (Data, diffPl, .inverse=TRUE)  # pressure vector
 in a-frame
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<akfit, echo=FALSE, include=TRUE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$AK <- cff * Data$QRF + cfs[1] + cfs[2] * Data$QRS + cfs[3] * Data$QCFS
\end_layout

\begin_layout Plain Layout

Data$DIFFPX <- diffPa[,1]
\end_layout

\begin_layout Plain Layout

Data$DIFFPY <- diffPa[,2]
\end_layout

\begin_layout Plain Layout

Data$DIFFPZ <- diffPa[,3]
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

## as for AK, decompose into slow and fast components
\end_layout

\begin_layout Plain Layout

CutoffPeriod <- 600		## as before
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

Data$AKS <- zoo::na.approx (as.vector(Data$AK), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

Data$AKS[is.na(Data$AKS)] <- 0
\end_layout

\begin_layout Plain Layout

Data$AKS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$AKS)
\end_layout

\begin_layout Plain Layout

Data$AKF <- Data$AK - Data$AKS
\end_layout

\begin_layout Plain Layout

Data$SSRDS <- zoo::na.approx (as.vector(Data$SSRD), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

Data$SSRDS[is.na(Data$SSRDS)] <- 0
\end_layout

\begin_layout Plain Layout

Data$SSRDS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$SSRDS)
\end_layout

\begin_layout Plain Layout

Data$SSRDF <- Data$SSRD - Data$SSRDS
\end_layout

\begin_layout Plain Layout

Data$DV1 <- with(Data, DIFFPZ / QC_GP)
\end_layout

\begin_layout Plain Layout

Data$DV2 <- with(Data, (DIFFPZ / QC_GP) * MACHG)
\end_layout

\begin_layout Plain Layout

Data$DV3 <- with(Data, DIFFPY / QC_GP)
\end_layout

\begin_layout Plain Layout

Data$DV4 <- with(Data, (DIFFPZ / QC_GP)^2)
\end_layout

\begin_layout Plain Layout

Data$DVS1 <- Data$DV3
\end_layout

\begin_layout Plain Layout

Data$DVS2 <- with(Data, MACHG * DIFFPY / QC_GP)
\end_layout

\begin_layout Plain Layout

Data$DVS3 <- Data$DV1
\end_layout

\begin_layout Plain Layout

Data$DV1S <- zoo::na.approx (as.vector(Data$DV1), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV1 <- mean(Data$DV1, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Data$DV1S[is.na(Data$DV1S)] <- meanDV1
\end_layout

\begin_layout Plain Layout

Data$DV1S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$DV1S)
\end_layout

\begin_layout Plain Layout

Data$DV1F <- Data$DV1 - Data$DV1S
\end_layout

\begin_layout Plain Layout

Data$DV2S <- zoo::na.approx (as.vector(Data$DV2), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV2 <- mean(Data$DV2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Data$DV2S[is.na(Data$DV2S)] <- meanDV2
\end_layout

\begin_layout Plain Layout

Data$DV2S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$DV2S)
\end_layout

\begin_layout Plain Layout

Data$DV2F <- Data$DV2 - Data$DV2S
\end_layout

\begin_layout Plain Layout

Data$DV3S <- zoo::na.approx (as.vector(Data$DV3), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV3 <- mean(Data$DV3, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Data$DV3S[is.na(Data$DV3S)] <- meanDV3
\end_layout

\begin_layout Plain Layout

Data$DV3S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$DV3S)
\end_layout

\begin_layout Plain Layout

Data$DV3F <- Data$DV3 - Data$DV3S
\end_layout

\begin_layout Plain Layout

Data$DV4S <- zoo::na.approx (as.vector(Data$DV4), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV4 <- mean(Data$DV4, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Data$DV4S[is.na(Data$DV4S)] <- meanDV4
\end_layout

\begin_layout Plain Layout

Data$DV4S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$DV4S)
\end_layout

\begin_layout Plain Layout

Data$DV4F <- Data$DV4 - Data$DV4S
\end_layout

\begin_layout Plain Layout

Data$DVS1S <- Data$DV3S
\end_layout

\begin_layout Plain Layout

Data$DVS1F <- Data$DV3F
\end_layout

\begin_layout Plain Layout

Data$DVS2S <- zoo::na.approx(as.vector(Data$DVS2), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDVS2 <- mean(Data$DVS2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

Data$DVS2S[is.na(Data$DVS2S)] <- meanDVS2
\end_layout

\begin_layout Plain Layout

Data$DVS2S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), Data$DVS2S)
\end_layout

\begin_layout Plain Layout

Data$DVS2F <- Data$DVS2 - Data$DVS2S
\end_layout

\begin_layout Plain Layout

Data$DVS3S <- Data$DV1S
\end_layout

\begin_layout Plain Layout

Data$DVS3F <- Data$DV1F
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Restrict fit to periods with low ROLL, and truncate 15 min at start/end
\end_layout

\begin_layout Plain Layout

## so that the filter start-and-end deviations don't affect the fit.
\end_layout

\begin_layout Plain Layout

## (first is.na test avoids NAs in Time where is.na(ROLL))
\end_layout

\begin_layout Plain Layout

DataF <- Data[!is.na(Data$ROLL) & abs(Data$ROLL) < 3, ]
\end_layout

\begin_layout Plain Layout

FN <- unique(DataF$RF)
\end_layout

\begin_layout Plain Layout

ir <- vector()
\end_layout

\begin_layout Plain Layout

for (F in FN) {
\end_layout

\begin_layout Plain Layout

  ix <- which (DataF$RF == F)
\end_layout

\begin_layout Plain Layout

  L <- length(ix)
\end_layout

\begin_layout Plain Layout

  ir <- c(ir, ix[1]:(ix[1]+899), (ix[L]-899):ix[L])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DataF <- DataF[-ir, ]
\end_layout

\begin_layout Plain Layout

## Eliminate a bad period in rf01, 32500--35000
\end_layout

\begin_layout Plain Layout

stime <- as.POSIXct('2018-01-16 03:25:00', tz='UTC')
\end_layout

\begin_layout Plain Layout

etime <- as.POSIXct('2018-01-16 04:05:00', tz='UTC')
\end_layout

\begin_layout Plain Layout

ir <- which(DataF$Time >= stime & DataF$Time <= etime)
\end_layout

\begin_layout Plain Layout

DataF <- DataF[-ir, ]
\end_layout

\begin_layout Plain Layout

fas <- lm(AKS ~ DV1S + DV2S + DV3S + DV4S, data=DataF)
\end_layout

\begin_layout Plain Layout

faf <- lm(AKF ~ DV1F + DV2F + DV3F - 1, data=DataF)  ## intercept not needed,
 suppressed
\end_layout

\begin_layout Plain Layout

cfas <- coef(fas)
\end_layout

\begin_layout Plain Layout

cfaf <- coef(faf)
\end_layout

\begin_layout Plain Layout

Data$AK_GPS <- with(Data, cfas[1] + cfas[2] * DV1S + cfas[3] * DV2S + cfas[4]
 * DV3S + cfas[5] * DV4S)
\end_layout

\begin_layout Plain Layout

Data$AK_GPF <- with(Data, cfaf[1] * DV1F + cfaf[2] * DV2F + cfaf[3] * DV3F)
\end_layout

\begin_layout Plain Layout

Data$AK_GP <- Data$AK_GPS + Data$AK_GPF
\end_layout

\begin_layout Plain Layout

DataF$AK_GPS <- with(DataF, cfas[1] + cfas[2] * DV1S + cfas[3] * DV2S +
 cfas[4] * DV3S + cfas[5] * DV4S)
\end_layout

\begin_layout Plain Layout

DataF$AK_GPF <- with(DataF, cfaf[1] * DV1F + cfaf[2] * DV2F + cfaf[3] *
 DV3F)
\end_layout

\begin_layout Plain Layout

DataF$AK_GP <- DataF$AK_GPS + DataF$AK_GPF
\end_layout

\begin_layout Plain Layout

## calculate residuals for some intermediate fits:
\end_layout

\begin_layout Plain Layout

cfas1 <- coef(lm(AKS ~ DV1S, data=DataF))
\end_layout

\begin_layout Plain Layout

cfaf1 <- coef(lm(AKF ~ DV1F - 1, data=DataF))
\end_layout

\begin_layout Plain Layout

atest1 <- with(DataF, cfas1[1] + cfas1[2] * DV1S + cfaf1[1] * DV1F)
\end_layout

\begin_layout Plain Layout

sig1 <- sqrt(with(DataF, sum((atest1-AK)^2, na.rm=TRUE) / (nrow(DataF))))
\end_layout

\begin_layout Plain Layout

cfas2 <- coef(lm(AKS ~ DV1S + DV2S, data=DataF))
\end_layout

\begin_layout Plain Layout

cfaf2 <- coef(lm(AKF ~ DV1F + DV2F - 1, data=DataF))
\end_layout

\begin_layout Plain Layout

atest2 <- with(DataF, cfas2[1] + cfas2[2] * DV1S + cfas2[3] * DV2S + 
\end_layout

\begin_layout Plain Layout

                      cfaf2[1] * DV1F + cfaf2[2] * DV2F)
\end_layout

\begin_layout Plain Layout

sig2 <- sqrt(with(DataF, sum((atest2-AK)^2, na.rm=TRUE) / (nrow(DataF))))
\end_layout

\begin_layout Plain Layout

cfas3 <- coef(lm(AKS ~ DV1S + DV2S + DV3S, data=DataF))
\end_layout

\begin_layout Plain Layout

cfaf3 <- coef(lm(AKF ~ DV1F + DV2F + DV3F - 1, data=DataF))
\end_layout

\begin_layout Plain Layout

atest3 <- with(DataF, cfas3[1] + cfas3[2] * DV1S + cfas3[3] * DV2S + cfas3[4]
 * DV3S + 
\end_layout

\begin_layout Plain Layout

                      cfaf3[1] * DV1F + cfaf3[2] * DV2F + cfaf3[3] * DV3F)
\end_layout

\begin_layout Plain Layout

sig3 <- sqrt(with(DataF, sum((atest3-AK)^2, na.rm=TRUE) / (nrow(DataF))))
\end_layout

\begin_layout Plain Layout

cfas4 <- coef(lm(AKS ~ DV1S + DV2S + DV3S + DV4S, data=DataF))
\end_layout

\begin_layout Plain Layout

cfaf4 <- cfaf3
\end_layout

\begin_layout Plain Layout

atest4 <- with(DataF, cfas4[1] + cfas4[2] * DV1S + cfas4[3] * DV2S + 
\end_layout

\begin_layout Plain Layout

             cfas4[4] * DV3S + cfas4[5] * DV4S +
\end_layout

\begin_layout Plain Layout

                      cfaf3[1] * DV1F + cfaf3[2] * DV2F + cfaf3[3] * DV3F)
\end_layout

\begin_layout Plain Layout

sig4 <- sqrt(with(DataF, sum((atest4-AK)^2, na.rm=TRUE) / (nrow(DataF))))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Empirical Coefficients
\end_layout

\begin_layout Subsubsection
Angle of Attack
\begin_inset CommandInset label
LatexCommand label
name "subsec:Calibration-AOA"

\end_inset


\end_layout

\begin_layout Standard
The standard method of calibrating the measurement of angle-of-attack is
 described in detail by 
\begin_inset CommandInset citation
LatexCommand cite
key "Cooper2016ncartn"

\end_inset

, and a revised approach is described in Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:AKRDcompF"

\end_inset

.
 The latter is used here.
 The goal then is to find an empirical equation that duplicates that angle
 of attack (here, AK) but uses measurements from the gust-pod.
 Because of flow distortion at the gust-pod, it is expected that the empirical
 relationship will be more complicated and will involve the horizontal as
 well as vertical pressure differences from the gust-pod.
 In addition, the data used for the fit should include various maneuvers
 in addition to the speed runs normally used for finding a representation
 of AKRD.
\end_layout

\begin_layout Standard
The data set used here is the combination of SOCRATES test flight #1, ferry
 flight #2, and research flight #1.
 Test flight 1 included a complete set of maneuvers, so that flight provides
 a good range of conditions for the fits.
 Research flight #1 included a low-level flight segment that is also important
 to include for characterization of this part of the flight envelope.
 The new variable will be called AK_GP and will be determined by linear
 fits to variables from the gust-pod after transformation to the a-frame.
 
\end_layout

\begin_layout Standard
In addition, an approach analogous to that for the complementary-filter
 representation of AKRD will be used because it provided an improved representat
ion of the angles of attack and sideslip.
 The same approach is taken: Split the reference AKRD into 
\begin_inset Quotes eld
\end_inset

slow
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

fast
\begin_inset Quotes erd
\end_inset

 components, represent them separately using empirical functions of variables
 that are similarly filtered, and then combine them to produce the result
 for AK_GP\SpecialChar endofsentence
 The following table shows the residual standard deviation for
 some choices of the empirical equation.
 The variables used are: 
\begin_inset Formula $\Delta p_{z}$
\end_inset

: the pressure difference between top-and-bottom pressure ports on the gust-pod
 after transformation to the a-frame; 
\begin_inset Formula $\Delta p_{y}$
\end_inset

: the corresponding difference between the starboard and port-side pressure
 ports; 
\begin_inset Formula $q_{c}$
\end_inset

: the dynamic pressure measured at the forward port on the gust-pod; and
 
\begin_inset Formula $M_{g}$
\end_inset

: the Mach number calculated using the uncorrected measurements QC_GP and
 PS_GP from the gust pod.
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Equation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
residual standard deviation [
\begin_inset Formula $^{\circ}$
\end_inset

]
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $a_{0}+a_{1}\frac{\Delta p_{z}}{q_{g}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig1,3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $"\,+a_{2}M_{g}\frac{\Delta p_{z}}{q_{g}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig2, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $"\,+a_{3}\frac{\Delta p_{y}}{q_{g}}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig3, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $"\,+a_{4}\left(\frac{\Delta p_{z}}{q_{g}}\right)^{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sig4, 3)}
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<akplot1, echo=FALSE, include=TRUE, fig.height=5, fig.cap='Comparison of
 gust-pod fit result (AK
\backslash

\backslash
_GP) to the complementary-filter radome-based value for angle of attack
 (AK), for SOCRATES test flight 1.
 Also shown as the red line is the difference multiplied by 5 to make the
 difference easier to interpret.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1, oma=c(1.1,0,0,0)) 
\end_layout

\begin_layout Plain Layout

with(DataF[DataF$RF == 51, ], plotWAC(data.frame(Time, AK, AK_GP, 5*(AK-AK_GP)),
 legend.position='topleft'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<akplot2, echo=FALSE, include=TRUE, fig.height=4, fig.cap='As in the preceding
 plot but expanded to show only the period of the speed run and without
 factor-of-five magnification of the difference (red line).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data[setRange (Data, 221035, 221510),], plotWAC(data.frame(Time, AK,
 AK_GP, (AK-AK_GP)), legend.position='topright'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The resulting fit has residual standard deviation similar to that obtained
 in typical calibrations leading to AKRD, and as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:akplot1}
\end_layout

\end_inset

 the five-coefficient fit provides a very good representation of AKRD.
 Figure.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:akplot2}
\end_layout

\end_inset

 shows an expanded view of the period of the speed run.
 The difference at large angle-of-attack (near 5
\begin_inset Formula $^{\circ}$
\end_inset

) is a little larger than elsewhere, but values of the angle-of-attack this
 large are seldom encountered except during maneuvers like this.
\end_layout

\begin_layout Subsubsection
Sideslip
\end_layout

\begin_layout Standard
Sideslip was handled in a similar manner, except that the reference SSRD
 was the standard variable calculated without separating into slow and fast
 components because there does not appear to be a varying offset to the
 standard sideslip angle as there is for angle-of-attack.
 That is not true for the gust-pod sideslip, however, so a complementary-filter
 representation was used for it as for angle-of-attack.
 Some exploration of possible variables to include in an empirical representatio
n led to this equation:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\beta=e_{0}+\frac{\Delta p_{y}}{q_{g}}\left(e_{0}+e_{1}M_{g}\right)+e_{2}\frac{\Delta p_{z}}{q_{g}}\label{eq:newSSG}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<ss-gp, include=TRUE, echo=FALSE, fig.cap='Comparison of SS
\backslash

\backslash
_GP, calculated using the new SOCRATES coefficients, to SSRD from the radome,
 for flights tf01, ff02, and rf01 (with some short omissions of obviously
 problematic measurements).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## Eliminate a bad period in ff01, 214000--214300
\end_layout

\begin_layout Plain Layout

stime <- as.POSIXct('2018-01-09 21:40:00', tz='UTC')
\end_layout

\begin_layout Plain Layout

etime <- as.POSIXct('2018-01-09 21:43:00', tz='UTC')
\end_layout

\begin_layout Plain Layout

ir <- which(DataF$Time >= stime & DataF$Time <= etime)
\end_layout

\begin_layout Plain Layout

DataF <- DataF[-ir, ]
\end_layout

\begin_layout Plain Layout

fss <- lm(SSRDS ~ DVS1S + DVS2S + DVS3S, data=DataF)
\end_layout

\begin_layout Plain Layout

## uses weighted fit to increase importance of yaw maneuver
\end_layout

\begin_layout Plain Layout

fsf <- lm(SSRDF ~ DVS1F + DVS2F + DVS3F - 1, data=DataF, weights=abs(DataF$SSRDF
))
\end_layout

\begin_layout Plain Layout

cfss <- coef(fss)
\end_layout

\begin_layout Plain Layout

cfsf <- coef(fsf)
\end_layout

\begin_layout Plain Layout

DataF$SS_GPS <- with(DataF, cfss[1] + cfss[2] * DVS1S + cfss[3] * DVS2S
 + cfss[4] * DVS3S)
\end_layout

\begin_layout Plain Layout

DataF$SS_GPF <- with(DataF, cfsf[1] * DVS1F + cfsf[2] * DVS2F + cfsf[3]
 * DVS3F)
\end_layout

\begin_layout Plain Layout

DataF$SS_GP <- DataF$SS_GPS + DataF$SS_GPF
\end_layout

\begin_layout Plain Layout

Data$SS_GPS <- with(Data, cfss[1] + cfss[2] * DVS1S + cfss[3] * DVS2S +
 cfss[4] * DVS3S)
\end_layout

\begin_layout Plain Layout

Data$SS_GPF <- with(Data, cfsf[1] * DVS1F + cfsf[2] * DVS2F + cfsf[3] *
 DVS3F)
\end_layout

\begin_layout Plain Layout

Data$SS_GP <- Data$SS_GPS + Data$SS_GPF
\end_layout

\begin_layout Plain Layout

with(DataF, plotWAC(data.frame(SSRD, SS_GP), xlab='SSRD', ylab='SS_GP', type='p')
)
\end_layout

\begin_layout Plain Layout

refline(-5,5)
\end_layout

\begin_layout Plain Layout

sigS <- sqrt(sum((DataF$SS_GP-DataF$SSRD)^2, na.rm=TRUE) / nrow(DataF))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<yaw-maneuver, include=TRUE, echo=FALSE, fig.cap='Comparison of SS
\backslash

\backslash
_GP, calculated using the new SOCRATES coefficients, to SSRD from the radome,
 for the yaw maneuver from SOCRATES tf01.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data[setRange(Data, 221500, 221900), ], plotWAC(data.frame(Time, SSRD,
 SS_GP), ylab='Sideslip angle [deg.]'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
which was used to fit the slow and fast components of SSRD, except for the
 fast component the constant 
\begin_inset Formula $e_{0}$
\end_inset

 was omitted.
 The residual standard deviation was 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(sigS,2)}
\end_layout

\end_inset


\begin_inset Formula $^{\circ}$
\end_inset

 for the set of three flights (tf01, ff02, rf01).
 The good correspondence between the radome-based sideslip angle and the
 gust-pod-based sideslip angle is shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:ss-gp}
\end_layout

\end_inset

, and the yaw maneuver from SOCRATES tf01 (22:16:00–22:18:30) is shown in
 Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:yaw-maneuver}
\end_layout

\end_inset

.
 The measurements from the radome and gust pod are in remarkable agreement
 through the period of this yaw maneuver.
\end_layout

\begin_layout Subsubsection
Airspeed
\end_layout

\begin_layout Standard
The equation developed in Cooper et al.
\begin_inset space ~
\end_inset

(2016) for airspeed was based on this fit to the ratio 
\begin_inset Formula $q/p$
\end_inset

 as measured by the standard system:
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\begin{equation}
\frac{q}{p}=d_{0}+d_{1}\frac{q_{g}}{p_{g}}+d_{2}M_{g}\frac{q_{g}}{p_{q}}+d_{3}\left(\frac{q_{g}}{p_{g}}\right)^{2}+d_{4}\frac{\Delta p_{\alpha,g}}{q_{g}}+d_{5}M_{g}+d_{6}\left(\frac{\Delta p_{\alpha,g}}{q_{g}}\right)^{2}+d_{7}M_{g}\frac{\Delta p_{\alpha,g}}{q_{g}}\label{eq:TASG}
\end{equation}

\end_inset

where 
\begin_inset Formula $q$
\end_inset

 is dynamic pressure, 
\begin_inset Formula $p$
\end_inset

 is ambient pressure, 
\begin_inset Formula $M_{g}$
\end_inset

 is the Mach number determined from the gust-pod measurements of dynamic
 and ambient pressure (
\begin_inset Formula $q_{g}$
\end_inset

 and 
\begin_inset Formula $p_{g}$
\end_inset

), and 
\begin_inset Formula $\Delta p_{\alpha,g}$
\end_inset

 is the pressure difference between top and bottom pressure ports on the
 gust-pod.
 The DEEPWAVE fit found coefficients {
\begin_inset Formula $d_{i}$
\end_inset

}={1.1940, 27.2893, 
\begin_inset Formula $-29.0483$
\end_inset

, 13.6231, 
\begin_inset Formula $-0.5936$
\end_inset

, 
\begin_inset Formula $-7.5812$
\end_inset

, 0.1554, 1.2607}.
 Repeating the fit for the same data set used to determine coefficients
 to represent the angles of attack and sideslip gave new coefficients as
 listed below and resulting predictions for 
\begin_inset Formula $q/p$
\end_inset

 as shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tasg}
\end_layout

\end_inset

.
 A reasonable fit was obtained, but the high-frequency spectral variance
 of the resulting airspeed had apparent weaknesses so an approach similar
 to that used for angle-of-attack was used for 
\begin_inset Formula $q/p$
\end_inset

: Split all the linear-predictor terms (like 
\begin_inset Formula $q_{g}/p_{g}$
\end_inset

) into complementary low-pass and high-pass components, fit separately,
 and combine the results.
 While the fit is very good, it is significantly different from that found
 in the DEEPWAVE project.
 The fit coefficients for the low-pass and high-pass terms are listed below
 (where the numbered terms in the fit correspond respectively to the numbered
 coefficients in (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:TASG"

\end_inset

)).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tasg, include=TRUE, echo=FALSE, fig.height=4, fig.width=4, fig.cap='Predicted
 ratio q/p from gust-pod measurements vs that measured by the standard wind-sens
ing system, for the composite data from tf01, ff02 and rf01.', cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataF$QR <- DataF$QCXC / DataF$PSXC
\end_layout

\begin_layout Plain Layout

# DataF$QRS <- zoo::na.approx (as.vector(DataF$QR), na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

# rmean <- rollapply(DataF$QRS, width=51, FUN=mean, fill=NA)
\end_layout

\begin_layout Plain Layout

# rmean <- zoo::na.approx (as.vector(rmean), na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

# DataF$QRS[is.na(DataF$QRS)] <- rmean[is.na(DataF$$QRS)]
\end_layout

\begin_layout Plain Layout

# meanQRS <- mean(DataF$QRS, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

# DataF$QRS[is.na(DataF$QRS)] <- meanQRS
\end_layout

\begin_layout Plain Layout

# DataF$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataF$QRS)
\end_layout

\begin_layout Plain Layout

DataF$QRS <- SplitDV (DataF$QR, 60)
\end_layout

\begin_layout Plain Layout

DataF$QRF <- DataF$QR - DataF$QRS
\end_layout

\begin_layout Plain Layout

DataF$QRG <- DataF$QC_GP / DataF$PS_GP
\end_layout

\begin_layout Plain Layout

DataF$DVT2 <- DataF$QRG
\end_layout

\begin_layout Plain Layout

DataF$MACHG <- MachNumber(DataF$PS_GP, DataF$QC_GP)
\end_layout

\begin_layout Plain Layout

DataF$DVT3 <- DataF$MACHG * DataF$DVT2
\end_layout

\begin_layout Plain Layout

DataF$ARG <- DataF$ADIF_GP / DataF$QC_GP
\end_layout

\begin_layout Plain Layout

DataF$DVT4 <- DataF$QRG^2
\end_layout

\begin_layout Plain Layout

DataF$DVT5 <- DataF$ARG
\end_layout

\begin_layout Plain Layout

DataF$DVT6 <- DataF$MACHG
\end_layout

\begin_layout Plain Layout

DataF$DVT7 <- DataF$ARG^2
\end_layout

\begin_layout Plain Layout

DataF$DVT8 <- DataF$MACHG * DataF$ARG
\end_layout

\begin_layout Plain Layout

for (V in c('DVT2', 'DVT3', 'DVT4', 'DVT5', 'DVT6', 'DVT7', 'DVT8')) {
\end_layout

\begin_layout Plain Layout

  VS <- sprintf ('%sS', V)
\end_layout

\begin_layout Plain Layout

  VF <- sprintf ('%sF', V)
\end_layout

\begin_layout Plain Layout

  DataF[, VS] <- SplitDV (DataF[, V], 60)
\end_layout

\begin_layout Plain Layout

  DataF[, VF] <- DataF[, V] - DataF[, VS]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

fmtS <- lm (QRS ~ DVT2S + DVT3S + DVT4S + DVT5S + DVT6S + DVT7S + DVT8S,
 data=DataF)
\end_layout

\begin_layout Plain Layout

fmtF <- lm (QRF ~ DVT2F + DVT3F + DVT4F + DVT5F + DVT6F + DVT7F + DVT8F
 - 1, data=DataF)
\end_layout

\begin_layout Plain Layout

print('Fit to the low-pass-filtered components:')
\end_layout

\begin_layout Plain Layout

SummarizeFit (fmtS)
\end_layout

\begin_layout Plain Layout

print('----------------------------------------')
\end_layout

\begin_layout Plain Layout

print('Fit to the high-pass-filtered components:')
\end_layout

\begin_layout Plain Layout

SummarizeFit (fmtF)
\end_layout

\begin_layout Plain Layout

# fmt <- lm (QR ~ QRG + I(MACHG  * QRG) + I(QRG^2) + ARG + MACHG + I(ARG^2)
 + I(MACHG*ARG), data=DataF)
\end_layout

\begin_layout Plain Layout

# cft <- coefficients(fmt)
\end_layout

\begin_layout Plain Layout

cftS <- coefficients(fmtS)
\end_layout

\begin_layout Plain Layout

cftF <- coefficients(fmtF)
\end_layout

\begin_layout Plain Layout

DataF$QRPS <- with(DataF, cftS[1] + cftS[2]*DVT2S + cftS[3]*DVT3S + cftS[4]*DVT4
S +
\end_layout

\begin_layout Plain Layout

                      cftS[5]*DVT5S + cftS[6]*DVT6S + cftS[7]*DVT7S + cftS[8]*DV
T8S)
\end_layout

\begin_layout Plain Layout

DataF$QRPF <- with(DataF, cftF[1]*DVT2F+cftF[2]*DVT3F+cftF[3]*DVT4F +
\end_layout

\begin_layout Plain Layout

                      cftF[4]*DVT5F+cftF[5]*DVT6F+cftF[6]*DVT7F+cftF[7]*DVT8F)
\end_layout

\begin_layout Plain Layout

# DataF$QRP <- with(DataF, cft[1]+cft[2]*QRG+cft[3]*MACHG*QRG+cft[4]*QRG^2+cft[5
]*ARG+cft[6]*MACHG+
\end_layout

\begin_layout Plain Layout

#                         cft[7]*ARG^2+cft[8]*MACHG*ARG)
\end_layout

\begin_layout Plain Layout

DataF$QRP <- DataF$QRPS + DataF$QRPF
\end_layout

\begin_layout Plain Layout

with(DataF, plotWAC (data.frame(QR, QRP), xlab='standard q/p', ylab='predicted
 q/p', 
\end_layout

\begin_layout Plain Layout

                     type='p', pch=20, col='blue'))
\end_layout

\begin_layout Plain Layout

# title('SOCRATES tf01 speed run only')
\end_layout

\begin_layout Plain Layout

cfdw <- c(1.1940, 27.2893, -29.0483, 13.6231, -0.5936, -7.5812, 0.1554, 1.2607)
\end_layout

\begin_layout Plain Layout

DataF$QRPD <- with(DataF, cfdw[1]+cfdw[2]*QRG+cfdw[3]*MACHG*QRG+cfdw[4]*QRG^2+cf
dw[5]*ARG+cfdw[6]*MACHG+
\end_layout

\begin_layout Plain Layout

                          cfdw[7]*ARG^2+cfdw[8]*MACHG*ARG)
\end_layout

\begin_layout Plain Layout

# with(DataF, points (data.frame(QR, QRPD), pch=20, col='black'))
\end_layout

\begin_layout Plain Layout

refline(0,6)
\end_layout

\begin_layout Plain Layout

# lines(c(0,1), c(0,1), col='darkgreen', lwd=2, lty=2)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Examples of Results
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newWindGP, include=TRUE, echo=FALSE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## previously calculated AK_GP, SS_GP, AK
\end_layout

\begin_layout Plain Layout

## for wind calculation, use TASX -- normally OK
\end_layout

\begin_layout Plain Layout

## but include TASG also:
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Data$QR <- Data$QCXC / Data$PSXC
\end_layout

\begin_layout Plain Layout

Data$QRG <- Data$QC_GP / Data$PS_GP
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

Data$ARG <- Data$ADIF_GP / Data$QC_GP
\end_layout

\begin_layout Plain Layout

Data$DVT2 <- Data$QRG
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(Data$PS_GP, Data$QC_GP)
\end_layout

\begin_layout Plain Layout

Data$DVT3 <- Data$MACHG * Data$DVT2
\end_layout

\begin_layout Plain Layout

Data$ARG <- Data$ADIF_GP / Data$QC_GP
\end_layout

\begin_layout Plain Layout

Data$DVT4 <- Data$QRG^2
\end_layout

\begin_layout Plain Layout

Data$DVT5 <- Data$ARG
\end_layout

\begin_layout Plain Layout

Data$DVT6 <- Data$MACHG
\end_layout

\begin_layout Plain Layout

Data$DVT7 <- Data$ARG^2
\end_layout

\begin_layout Plain Layout

Data$DVT8 <- Data$MACHG * Data$ARG
\end_layout

\begin_layout Plain Layout

for (V in c('DVT2', 'DVT3', 'DVT4', 'DVT5', 'DVT6', 'DVT7', 'DVT8')) {
\end_layout

\begin_layout Plain Layout

  VS <- sprintf ('%sS', V)
\end_layout

\begin_layout Plain Layout

  VF <- sprintf ('%sF', V)
\end_layout

\begin_layout Plain Layout

  Data[, VS] <- SplitDV (Data[, V], 60)
\end_layout

\begin_layout Plain Layout

  Data[, VF] <- Data[, V] - Data[, VS]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

Data$QRPS <- with(Data, cftS[1] + cftS[2]*DVT2S + cftS[3]*DVT3S + cftS[4]*DVT4S
 +
\end_layout

\begin_layout Plain Layout

                      cftS[5]*DVT5S + cftS[6]*DVT6S + cftS[7]*DVT7S + cftS[8]*DV
T8S)
\end_layout

\begin_layout Plain Layout

Data$QRPF <- with(Data, cftF[1]*DVT2F+cftF[2]*DVT3F+cftF[3]*DVT4F +
\end_layout

\begin_layout Plain Layout

                      cftF[4]*DVT5F+cftF[5]*DVT6F+cftF[6]*DVT7F+cftF[7]*DVT8F)
\end_layout

\begin_layout Plain Layout

Data$QRP <- Data$QRPS + Data$QRPF
\end_layout

\begin_layout Plain Layout

## replace MACHG with new value:
\end_layout

\begin_layout Plain Layout

Data$MACHG <- MachNumber(1, Data$QRP)
\end_layout

\begin_layout Plain Layout

Data$TASG <- TrueAirspeed(Data$MACHG, Data$ATX, Data$EWX / Data$PSXC)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataW <- Data 		## work data.frame for the wind calculation
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- Data$AK_GP
\end_layout

\begin_layout Plain Layout

DataW$SSLIP <- Data$SS_GP
\end_layout

\begin_layout Plain Layout

DataW$VEW <- Data$CVEW_GP
\end_layout

\begin_layout Plain Layout

DataW$VNS <- Data$CVNS_GP
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- Data$CVSPD_GP
\end_layout

\begin_layout Plain Layout

DataW$TASX <- Data$TASG  ## might be better to use TAS from pitot-static?
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW, CompF=FALSE)
\end_layout

\begin_layout Plain Layout

Data$WIG <- DataN$WIN
\end_layout

\begin_layout Plain Layout

Data$WSG <- DataN$WSN
\end_layout

\begin_layout Plain Layout

Data$WDG <- DataN$WDN
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots1, include=TRUE, fig.cap='Comparison of angles of attack from the
 standard calculation (AKRD), the complementary-filter solution for the
 radome (AK), and the measurement from the gust pod (AK
\backslash

\backslash
_GP).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, AKRD, AK, AK_GP), lwd=c(2,2,1), lty=c(1,1,4),
 legend.position='topleft'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots2, include=TRUE, fig.cap='Comparison of sideslip angles from the
 standard calculation (SSRD) and from the gust pod (SS
\backslash

\backslash
_GP).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

with(Data, plotWAC(data.frame(Time, SSRD, SS_GP), legend.position='topleft'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots3, include=TRUE, fig.cap='Comparison of measurements of the vertical
 wind from the standard calculation (WIC) and from the gust pod (WIG).
 Also shown in the result from the complementary-filter solution applied
 to the radome system (WIN).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataW <- Data
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- Data$AK
\end_layout

\begin_layout Plain Layout

DataN <- WindProcessor (DataW)
\end_layout

\begin_layout Plain Layout

Data$WIY <- DataN$WIN 
\end_layout

\begin_layout Plain Layout

stime <- as.POSIXct('2018-01-16 02:00:00', tz='UTC')
\end_layout

\begin_layout Plain Layout

etime <- as.POSIXct('2018-01-16 02:30:00', tz='UTC')
\end_layout

\begin_layout Plain Layout

ir <- which(Data$Time >= stime & Data$Time <= etime)
\end_layout

\begin_layout Plain Layout

with(Data[Data$RF == 1, ], plotWAC(data.frame(Time, SmoothInterp(WIC), 
\end_layout

\begin_layout Plain Layout

                        SmoothInterp(WIY), SmoothInterp(WIG)), 
\end_layout

\begin_layout Plain Layout

                        lwd=c(2,2,2), lty=c(1,1,4), ylim=c(-2,2),
\end_layout

\begin_layout Plain Layout

                        legend.position='topright'))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<tfplots4, include=TRUE, fig.cap='Comparison of measurements of the horizontal
 wind from the standard calculation (WDC amd WSC) and from the gust pod
 (WDG and WSG).'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol = 1), widths = 1, heights = c(5,6)) 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1) + 0.1)
\end_layout

\begin_layout Plain Layout

with(Data[Data$RF == 1, ], plotWAC(data.frame(Time, WDC, WDG)))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1) + 0.1)
\end_layout

\begin_layout Plain Layout

with(Data[Data$RF == 1, ], plotWAC(data.frame(Time, WSC, WSG), legend.position='to
pright'))
\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol = 1), widths = 1, heights = c(6)) 
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1) + 0.1)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This processing recommended in the final section of this report was applied
 to SOCRATES research flight #1 so that the gust-pod measurements of wind
 can be compared to the standard wind measurements based on the radome.
 Figure
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:tfplots4}
\end_layout

\end_inset

 shows that the horizontal wind from the gust pod matches that from the
 standard system quite well.
\begin_inset Foot
status open

\begin_layout Plain Layout
The large spikes are associated with periods of missing gust-pod data.
 The spike-removal algorithm discussed in Sect.
\begin_inset space ~
\end_inset

5.2 has not been used when constructing these plots.
\end_layout

\end_inset

 The wind measurements from the gust pod, entirely independent of variables
 provided by the radome, provide a valid measurement of the wind that is
 in reasonable agreement with the standard system and can provide a back-up
 measurement in cases where some problem interferes with the measurements
 from the standard system.
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Subsection

\emph on
Summary
\begin_inset CommandInset label
LatexCommand label
name "sec:Summary"

\end_inset


\end_layout

\begin_layout Standard
Use these equations and coefficients to find the relative-flow angles and
 ratio of dynamic to ambient pressure (with MACHGG, different from MACHG
 defined below, defined as the Mach number calculated from QC_GP and PS_GP).
 The variables DIFFPY and DIFFPZ are defined earlier as the pressure-difference
 components measured by the gust pod and then transformed to the a-frame.
 These definitions are also used: ARG=ADIF_GP/QC_GP and QRG=QC_GP/PS_GP).
 Because the coordinate-frame transformations and extensive splitting for
 complementary representation of the results are complex, it seems preferable
 to add these variables in second-pass processing.
 That is also a convenient way to add the complementary-filter result for
 AKRD and WIC (here, AK and WIY).
\end_layout

\begin_layout Standard
In the following summary, the function 
\begin_inset Quotes eld
\end_inset

bf()
\begin_inset Quotes erd
\end_inset

 denotes the low-pass Butterworth filter and 
\begin_inset Quotes eld
\end_inset

cf()
\begin_inset Quotes erd
\end_inset

 is the complementary high-pass filter.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
AK_GP: 
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfas[1],digits=5,nsmall=4)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfas[2],digits=5,nsmall=4)}
\end_layout

\end_inset

 * bf(DIFFPZ / QC_GP) + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfas[3],digits=5,nsmall=4)}
\end_layout

\end_inset

 * bf(DIFFPZ/QC_GP*MACHGG) + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfas[4],digits=5,nsmall=4)}
\end_layout

\end_inset

 * bf(DIFFPY/QC_GP) + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfas[5],digits=5,nsmall=4)}
\end_layout

\end_inset

 * bf(DIFFPZ / QC_GP)^2) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfaf[1],digits=5,nsmall=4)}
\end_layout

\end_inset

 * cf(DIFFPZ/QC_GP) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfaf[2],digits=5,nsmall=4)}
\end_layout

\end_inset

 * cf(DIFFPZ/QC_GP*MACHGG) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfaf[3],digits=5,nsmall=4)}
\end_layout

\end_inset

 * cf(DIFFPY/QC_GP) 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
SS_GP: 
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfss[1], 5)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfss[2], 5)}
\end_layout

\end_inset

 * bf(DIFFPY/QC_GP) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfss[3], 5)}
\end_layout

\end_inset

 * bf(DIFFPY/QC_GP * MACHGG) + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cfss[4], 5)}
\end_layout

\end_inset

 * bf(DIFFPZ/QC_GP) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfsf[1],digits=5,nsmall=4)}
\end_layout

\end_inset

 * cf(DIFPY/QC_GP) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfsf[2],digits=5,nsmall=4)}
\end_layout

\end_inset

 * cf(DIFFPY/QC_GP*MACHGG) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cfsf[3],digits=5,nsmall=4)}
\end_layout

\end_inset

 * cf(DIFFPZ/QC_GP) 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
QP_GP: 
\series default

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{format(cftS[1], digits=5, nsmall=4)}
\end_layout

\end_inset

 + 
\begin_inset Newline newline
\end_inset

bf(QRG) * (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[2], 5)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[3], 5)}
\end_layout

\end_inset

 * bf(MACHGG) + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[4], 5)}
\end_layout

\end_inset

 * bf(QRG)) +
\begin_inset Newline newline
\end_inset

bf(ARG) * (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[5], 5)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[7], 5)}
\end_layout

\end_inset

 * bf(ARG) + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[8], 5)}
\end_layout

\end_inset

 * bf(MACHGG)) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftS[6], 5)}
\end_layout

\end_inset

 * bf(MACHGG) +
\begin_inset Newline newline
\end_inset

cf(QRG) * (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[1], 5)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[2], 5)}
\end_layout

\end_inset

 * cf(MACHGG) + 
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[3], 5)}
\end_layout

\end_inset

 * cf(QRG)) +
\begin_inset Newline newline
\end_inset

cf(ARG) * (
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[4], 5)}
\end_layout

\end_inset

 + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[6], 5)}
\end_layout

\end_inset

 * cf(ARG) + 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[7], 5)}
\end_layout

\end_inset

 * cf(MACHGG)) +
\begin_inset Newline newline
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
Sexpr{round(cftF[5], 5)}
\end_layout

\end_inset

 * cf(MACHGG)
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
MACHG:
\series default
 Calculate from QP_GP: 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\mathrm{MACHG}=\sqrt{\frac{c_{v}}{R_{a}}((1+\mathrm{QP\_GP})^{R_{a}/c_{p}}-1)}
\]

\end_inset

where 
\begin_inset Formula $c_{p},\,c_{v},\,R_{a}$
\end_inset

 are respectively the specific heat at constant pressure, specific heat
 at constant volume, and gas constant for air.
 The appropriate respective values for dry air are {1004.728, 717.6631, 287.07}.
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
TASG: 
\series default
Calculate from MACHG and ATX (optionally with humidity correction, here
 and in the calculation of MACHG).
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000

\series bold
Wind:
\series default
 Calculate using gust() but with TASG, CVEW_GP, CVNS_GP, CVSPD_GP, CPITCH_GP,
 CROLL_GP, CTHDG_GP, AK_GP, and SS_GP used in place of the usual variables
 from the standard wind system.
 This gives a wind measurement that is not dependent on any information
 from the standard system except temperature.
\end_layout

\begin_layout Standard
The remaining aspect to discuss in this report is the performance of the
 gust pod at high rate.
 In Section 5, that discussion will be combined with consideration of the
 standard wind measurements and those as modified by using the pitot-static
 sensor.
 
\end_layout

\begin_layout Section
High-Rate Measurements 
\end_layout

\begin_layout Standard
There are now four ways to determine the wind vector:
\end_layout

\begin_layout Enumerate
Use the standard measurements from the radome, standard pitot tube, ambient
 pressure, and velocity relative to the ground.
 This is the system discussed extensively by 
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

;
\end_layout

\begin_layout Enumerate
Modify that system by using the airspeed measurement from the new pitot-static
 system;
\end_layout

\begin_layout Enumerate
Calculate the wind from the measurements provided by the gust pod; and
\end_layout

\begin_layout Enumerate
Use the Laser Air Motion Sensor.
 This instrument is not part of the SOCRATES instrumentation so it will
 not be discussed further here, but it provided valuable confirmation that
 the corrections applied to the standard measurements of ambient and dynamic
 pressure remain valid as originally determined from the LAMS.
\end_layout

\begin_layout Standard
The emphasis in this section will be on the high-rate measurements.
\end_layout

\begin_layout Subsection
Constructing the high-rate data.frame
\end_layout

\begin_layout Standard
In this report, to date only the high-rate measurements from the test and
 ferry flights and from research flight #1 are available to the author.
 The following discussion will be based mostly on the high-rate data from
 research flight #1.
 For the purposes of this study, those measurements were processed as discussed
 in Section 3 to incorporate the pitot-static sensor into the wind measurements
 (as new variables by using a variable TASTC that is derived from the revised
 dynamic pressure QCTC, the filtered ambient pressure measurement PSFCF,
 and the air temperature ATX.
 In other regards the wind calculation is standard and results in the variables
 WDTC, WSTC, WITC, UXTC and VYTC (analogous to the standard variables WDC,
 WSC, WIC, UXC and VYC).
 In the base of the gust pod, the algorithm developed in Section 4 leads
 similarly to variables WDG, WSG, WIG, UXG and VYG.
 A processor for adding these variables to the original netCDF file is discussed
 in the final section, but for use in this report all those variables have
 been added to a standard high-rate data.frame.
 The relevant code is in the 
\begin_inset Quotes eld
\end_inset

getHRdata
\begin_inset Quotes erd
\end_inset

 chunk of R code in this program file.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<getHRdata, include=TRUE, echo=FALSE, cache=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Flight <- "rf01_hr"  
\end_layout

\begin_layout Plain Layout

Rate <- 25
\end_layout

\begin_layout Plain Layout

Project <- "SOCRATES"
\end_layout

\begin_layout Plain Layout

VarList <- unique (c(VarList, VL, VarNames, 'UXC', 'VYC'))
\end_layout

\begin_layout Plain Layout

fname = sprintf("%s%s/%s%s.nc", Directory, Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

DataHR <- getNetCDF(sprintf('%s%s/%srf01_hr.nc', Directory, Project, Project),
 VarList, Start=34500, End=51500)
\end_layout

\begin_layout Plain Layout

DataHR$PSFF <- zoo::na.approx(as.vector(DataHR$PSXC), maxgap=1000*Rate, na.rm=FALSE
)
\end_layout

\begin_layout Plain Layout

meanPSFF <- mean(DataHR$PSFF, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DataHR$PSFF[is.na(DataHR$PSFF)] <- meanPSFF
\end_layout

\begin_layout Plain Layout

DataHR$PSFF <- signal::filtfilt (signal::butter (3, 2/(2*25), type='low'),
 DataHR$PSFF)
\end_layout

\begin_layout Plain Layout

DataHR$PTOT2 <- DataHR$QCTF + DataHR$PSTF
\end_layout

\begin_layout Plain Layout

DataHR$QCTC <- DataHR$PTOT2 - DataHR$PSFF
\end_layout

\begin_layout Plain Layout

DataHR$TASTC <- TrueAirspeed (MachNumber(DataHR$PSFF, DataHR$QCTC), DataHR$ATX,
 DataHR$EWX / DataHR$PSXC)
\end_layout

\begin_layout Plain Layout

DataW <- DataHR
\end_layout

\begin_layout Plain Layout

DataW$TASX <- DataHR$TASTC
\end_layout

\begin_layout Plain Layout

DataW <- WindProcessor(DataW)
\end_layout

\begin_layout Plain Layout

DataHR$WDTC <- DataW$WDN
\end_layout

\begin_layout Plain Layout

DataHR$WSTC <- DataW$WSN
\end_layout

\begin_layout Plain Layout

DataHR$WITC <- DataW$WIN
\end_layout

\begin_layout Plain Layout

hdg <- DataHR$THDG * Cradeg 
\end_layout

\begin_layout Plain Layout

wd <- DataHR$WDTC * Cradeg + pi 
\end_layout

\begin_layout Plain Layout

DataHR$UXTC <- DataHR$WSTC * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd)) 
\end_layout

\begin_layout Plain Layout

hdg <- hdg - pi/2 
\end_layout

\begin_layout Plain Layout

DataHR$VYTC <- DataHR$WSTC * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

## Finished with pitot-static; next add the gust-pod variables
\end_layout

\begin_layout Plain Layout

D <- DataHR    ## (for simplicity in typing)
\end_layout

\begin_layout Plain Layout

D$QR <- D$ADIFR / D$QCF
\end_layout

\begin_layout Plain Layout

D$QR[D$QCF < 20] <- NA
\end_layout

\begin_layout Plain Layout

D$QR[is.infinite(D$QR)] <- NA
\end_layout

\begin_layout Plain Layout

D$M <- MachNumber (D$PSF, D$QCF)
\end_layout

\begin_layout Plain Layout

D$WICS <- SmoothInterp (D$WIC)
\end_layout

\begin_layout Plain Layout

CutoffPeriod <- 600 * Rate
\end_layout

\begin_layout Plain Layout

D$QRS <- zoo::na.approx (as.vector(D$QR), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$QRS[is.na(D$QRS)] <- 0
\end_layout

\begin_layout Plain Layout

D$QRS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QRS)
\end_layout

\begin_layout Plain Layout

D$QRF <-  D$QR - D$QRS
\end_layout

\begin_layout Plain Layout

D$QCFS <- zoo::na.approx (as.vector(D$QCF), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$QCFS[is.na(D$QCFS)] <- 0
\end_layout

\begin_layout Plain Layout

D$QCFS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$QCFS)
\end_layout

\begin_layout Plain Layout

D$MS <- zoo::na.approx (as.vector(D$M), maxgap=1000*Rate, na.rm = FALSE)
\end_layout

\begin_layout Plain Layout

D$MS[is.na(D$MS)] <- 0
\end_layout

\begin_layout Plain Layout

D$MS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), D$MS)
\end_layout

\begin_layout Plain Layout

D$MF <-  D$M - D$MS
\end_layout

\begin_layout Plain Layout

DataHR <- D
\end_layout

\begin_layout Plain Layout

rm('D')
\end_layout

\begin_layout Plain Layout

diffP <- c(rep(0, nrow(DataHR)), DataHR$BDIF_GP, DataHR$ADIF_GP)  ## check
 signs!!
\end_layout

\begin_layout Plain Layout

dim(diffP) <- c(nrow(DataHR), 3)
\end_layout

\begin_layout Plain Layout

DF <- data.frame(ROLL=DataHR$CROLL_GP, PITCH=DataHR$CPITCH_GP, THDG=DataHR$CTHDG_
GP)
\end_layout

\begin_layout Plain Layout

diffPl <- Ranadu::XformLA (DF, diffP)  ## DF contains gustpod attitude angles
\end_layout

\begin_layout Plain Layout

diffPa <- Ranadu::XformLA (DataHR, diffPl, .inverse=TRUE)  # pressure vector
 in a-frame
\end_layout

\begin_layout Plain Layout

DataHR$AK <- cff * DataHR$QRF + cfs[1] + cfs[2] * DataHR$QRS + cfs[3] *
 DataHR$QCFS
\end_layout

\begin_layout Plain Layout

DataHR$DIFFPX <- diffPa[,1]
\end_layout

\begin_layout Plain Layout

DataHR$DIFFPY <- diffPa[,2]
\end_layout

\begin_layout Plain Layout

DataHR$DIFFPZ <- diffPa[,3]
\end_layout

\begin_layout Plain Layout

DataHR$MACHG <- MachNumber(DataHR$PS_GP, DataHR$QC_GP)
\end_layout

\begin_layout Plain Layout

## as for AK, decompose into slow and fast components
\end_layout

\begin_layout Plain Layout

DataHR$AKS <- zoo::na.approx (as.vector(DataHR$AK), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

DataHR$AKS[is.na(DataHR$AKS)] <- 0
\end_layout

\begin_layout Plain Layout

DataHR$AKS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$AKS)
\end_layout

\begin_layout Plain Layout

DataHR$AKF <- DataHR$AK - DataHR$AKS
\end_layout

\begin_layout Plain Layout

DataHR$SSRDS <- zoo::na.approx (as.vector(DataHR$SSRD), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

DataHR$SSRDS[is.na(DataHR$SSRDS)] <- 0
\end_layout

\begin_layout Plain Layout

DataHR$SSRDS <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$SSR
DS)
\end_layout

\begin_layout Plain Layout

DataHR$SSRDF <- DataHR$SSRD - DataHR$SSRDS
\end_layout

\begin_layout Plain Layout

DataHR$DV1 <- with(DataHR, DIFFPZ / QC_GP)
\end_layout

\begin_layout Plain Layout

DataHR$DV2 <- with(DataHR, (DIFFPZ / QC_GP) * MACHG)
\end_layout

\begin_layout Plain Layout

DataHR$DV3 <- with(DataHR, DIFFPY / QC_GP)
\end_layout

\begin_layout Plain Layout

DataHR$DV4 <- with(DataHR, (DIFFPZ / QC_GP)^2)
\end_layout

\begin_layout Plain Layout

DataHR$DVS1 <- DataHR$DV3
\end_layout

\begin_layout Plain Layout

DataHR$DVS2 <- with(DataHR, MACHG * DIFFPY / QC_GP)
\end_layout

\begin_layout Plain Layout

DataHR$DVS3 <- DataHR$DV1
\end_layout

\begin_layout Plain Layout

DataHR$DV1S <- zoo::na.approx (as.vector(DataHR$DV1), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV1 <- mean(DataHR$DV1, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DataHR$DV1S[is.na(DataHR$DV1S)] <- meanDV1
\end_layout

\begin_layout Plain Layout

DataHR$DV1S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$DV1S
)
\end_layout

\begin_layout Plain Layout

DataHR$DV1F <- DataHR$DV1 - DataHR$DV1S
\end_layout

\begin_layout Plain Layout

DataHR$DV2S <- zoo::na.approx (as.vector(DataHR$DV2), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV2 <- mean(DataHR$DV2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DataHR$DV2S[is.na(DataHR$DV2S)] <- meanDV2
\end_layout

\begin_layout Plain Layout

DataHR$DV2S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$DV2S
)
\end_layout

\begin_layout Plain Layout

DataHR$DV2F <- DataHR$DV2 - DataHR$DV2S
\end_layout

\begin_layout Plain Layout

DataHR$DV3S <- zoo::na.approx (as.vector(DataHR$DV3), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV3 <- mean(DataHR$DV3, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DataHR$DV3S[is.na(DataHR$DV3S)] <- meanDV3
\end_layout

\begin_layout Plain Layout

DataHR$DV3S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$DV3S
)
\end_layout

\begin_layout Plain Layout

DataHR$DV3F <- DataHR$DV3 - DataHR$DV3S
\end_layout

\begin_layout Plain Layout

DataHR$DV4S <- zoo::na.approx (as.vector(DataHR$DV4), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDV4 <- mean(DataHR$DV4, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DataHR$DV4S[is.na(DataHR$DV4S)] <- meanDV4
\end_layout

\begin_layout Plain Layout

DataHR$DV4S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$DV4S
)
\end_layout

\begin_layout Plain Layout

DataHR$DV4F <- DataHR$DV4 - DataHR$DV4S
\end_layout

\begin_layout Plain Layout

DataHR$DVS1S <- DataHR$DV3S
\end_layout

\begin_layout Plain Layout

DataHR$DVS1F <- DataHR$DV3F
\end_layout

\begin_layout Plain Layout

DataHR$DVS2S <- zoo::na.approx(as.vector(DataHR$DVS2), maxgap=1000, na.rm=FALSE)
\end_layout

\begin_layout Plain Layout

meanDVS2 <- mean(DataHR$DVS2, na.rm=TRUE)
\end_layout

\begin_layout Plain Layout

DataHR$DVS2S[is.na(DataHR$DVS2S)] <- meanDVS2
\end_layout

\begin_layout Plain Layout

DataHR$DVS2S <- signal::filtfilt (signal::butter (3, 2/CutoffPeriod), DataHR$DVS
2S)
\end_layout

\begin_layout Plain Layout

DataHR$DVS2F <- DataHR$DVS2 - DataHR$DVS2S
\end_layout

\begin_layout Plain Layout

DataHR$DVS3S <- DataHR$DV1S
\end_layout

\begin_layout Plain Layout

DataHR$DVS3F <- DataHR$DV1F
\end_layout

\begin_layout Plain Layout

DataHR$AK_GPS <- with(DataHR, cfas[1] + cfas[2] * DV1S + cfas[3] * DV2S
 + cfas[4] * DV3S + cfas[5] * DV4S)
\end_layout

\begin_layout Plain Layout

DataHR$AK_GPF <- with(DataHR, cfaf[1] * DV1F + cfaf[2] * DV2F + cfaf[3]
 * DV3F)
\end_layout

\begin_layout Plain Layout

DataHR$AK_GP <- DataHR$AK_GPS + DataHR$AK_GPF
\end_layout

\begin_layout Plain Layout

DataHR$SS_GPS <- with(DataHR, cfss[1] + cfss[2] * DVS1S + cfss[3] * DVS2S
 + cfss[4] * DVS3S)
\end_layout

\begin_layout Plain Layout

DataHR$SS_GPF <- with(DataHR, cfsf[1] * DVS1F + cfsf[2] * DVS2F + cfsf[3]
 * DVS3F)
\end_layout

\begin_layout Plain Layout

DataHR$SS_GP <- DataHR$SS_GPS + DataHR$SS_GPF
\end_layout

\begin_layout Plain Layout

DataHR$QR <- DataHR$QCXC / DataHR$PSXC
\end_layout

\begin_layout Plain Layout

######################################
\end_layout

\begin_layout Plain Layout

DataHR$QRG <- DataHR$QC_GP / DataHR$PS_GP
\end_layout

\begin_layout Plain Layout

DataHR$DVT2 <- DataHR$QRG
\end_layout

\begin_layout Plain Layout

DataHR$MACHG <- MachNumber(DataHR$PS_GP, DataHR$QC_GP)
\end_layout

\begin_layout Plain Layout

DataHR$DVT3 <- DataHR$MACHG * DataHR$DVT2
\end_layout

\begin_layout Plain Layout

DataHR$ARG <- DataHR$ADIF_GP / DataHR$QC_GP
\end_layout

\begin_layout Plain Layout

DataHR$DVT4 <- DataHR$QRG^2
\end_layout

\begin_layout Plain Layout

DataHR$DVT5 <- DataHR$ARG
\end_layout

\begin_layout Plain Layout

DataHR$DVT6 <- DataHR$MACHG
\end_layout

\begin_layout Plain Layout

DataHR$DVT7 <- DataHR$ARG^2
\end_layout

\begin_layout Plain Layout

DataHR$DVT8 <- DataHR$MACHG * DataHR$ARG
\end_layout

\begin_layout Plain Layout

for (V in c('DVT2', 'DVT3', 'DVT4', 'DVT5', 'DVT6', 'DVT7', 'DVT8')) {
\end_layout

\begin_layout Plain Layout

  VS <- sprintf ('%sS', V)
\end_layout

\begin_layout Plain Layout

  VF <- sprintf ('%sF', V)
\end_layout

\begin_layout Plain Layout

  DataHR[, VS] <- SplitDV (DataHR[, V], 60*25)
\end_layout

\begin_layout Plain Layout

  DataHR[, VF] <- DataHR[, V] - DataHR[, VS]
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DataHR$QRPS <- with(DataHR, cftS[1] + cftS[2]*DVT2S + cftS[3]*DVT3S + cftS[4]*DV
T4S +
\end_layout

\begin_layout Plain Layout

                      cftS[5]*DVT5S + cftS[6]*DVT6S + cftS[7]*DVT7S + cftS[8]*DV
T8S)
\end_layout

\begin_layout Plain Layout

DataHR$QRPF <- with(DataHR, cftF[1]*DVT2F+cftF[2]*DVT3F+cftF[3]*DVT4F +
\end_layout

\begin_layout Plain Layout

                      cftF[4]*DVT5F+cftF[5]*DVT6F+cftF[6]*DVT7F+cftF[7]*DVT8F)
\end_layout

\begin_layout Plain Layout

# DataHR$QRP <- with(DataHR, cft[1]+cft[2]*QRG+cft[3]*MACHG*QRG+cft[4]*QRG^2+cft
[5]*ARG+cft[6]*MACHG+
\end_layout

\begin_layout Plain Layout

#                         cft[7]*ARG^2+cft[8]*MACHG*ARG)
\end_layout

\begin_layout Plain Layout

DataHR$QRP <- DataHR$QRPS + DataHR$QRPF
\end_layout

\begin_layout Plain Layout

######################################
\end_layout

\begin_layout Plain Layout

## replace MACHG with new value:
\end_layout

\begin_layout Plain Layout

DataHR$MACHG <- MachNumber(1, DataHR$QRP)
\end_layout

\begin_layout Plain Layout

DataHR$TASG <- TrueAirspeed(DataHR$MACHG, DataHR$ATX, DataHR$EWX / DataHR$PSXC)
\end_layout

\begin_layout Plain Layout

## have all variables; do wind calculation
\end_layout

\begin_layout Plain Layout

DataW <- DataHR
\end_layout

\begin_layout Plain Layout

DataW$TASX <- DataHR$TASG
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- DataHR$AK_GP
\end_layout

\begin_layout Plain Layout

DataW$SSLIP <- DataHR$SS_GP
\end_layout

\begin_layout Plain Layout

# DataW$PITCH <- DataHR$CPITCH_GP  ## don't want these; already to a-frame
\end_layout

\begin_layout Plain Layout

DataW$VEW <- DataHR$CVEW_GP
\end_layout

\begin_layout Plain Layout

DataW$VNS <- DataHR$CVNS_GP
\end_layout

\begin_layout Plain Layout

DataW$GGVSPD <- DataHR$CVSPD_GP
\end_layout

\begin_layout Plain Layout

DataW <- WindProcessor(DataW, CompF=FALSE)
\end_layout

\begin_layout Plain Layout

DataHR$WDG <- DataW$WDN
\end_layout

\begin_layout Plain Layout

DataHR$WSG <- DataW$WSN
\end_layout

\begin_layout Plain Layout

DataHR$WIG <- DataW$WIN
\end_layout

\begin_layout Plain Layout

hdg <- DataHR$THDG * Cradeg 
\end_layout

\begin_layout Plain Layout

wd <- DataHR$WDG * Cradeg + pi 
\end_layout

\begin_layout Plain Layout

DataHR$UXG <- DataHR$WSG * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd)) 
\end_layout

\begin_layout Plain Layout

hdg <- hdg - pi/2 
\end_layout

\begin_layout Plain Layout

DataHR$VYG <- DataHR$WSG * (sin(hdg) * sin(wd) + cos(hdg) * cos(wd))
\end_layout

\begin_layout Plain Layout

DataW <- DataHR
\end_layout

\begin_layout Plain Layout

DataW$ATTACK <- DataHR$AK
\end_layout

\begin_layout Plain Layout

DataW <- WindProcessor(DataW, CompF=FALSE)
\end_layout

\begin_layout Plain Layout

DataHR$WIY <- DataW$WIN
\end_layout

\begin_layout Plain Layout

rm('DataW')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<addWind, echo=FALSE, include=TRUE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source('chunks/AddWind.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figures 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HRplots}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:HRUVplots}
\end_layout

\end_inset

 show comparisons among the three measurements of the wind vector.
 All are in very good agreement, although there are occasional spikes in
 all that will be a problem for calculations of the spectral variance.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HRplots, include=TRUE, echo=FALSE, fig.cap='Comparisons of the wind components
 from the standard system (suffix C), the standard system modified to use
 the pitot-static sensor for airspeed (suffix TC), and the gust pod (suffix
 G).
 The vertical wind measurements have a 60-s smoothing function applied because
 otherwise the noise obscures the differences, and for vertical wind the
 added variable WIY (cyan color) is the vertical wind that uses the angle-of-att
ack from the complementary-filter algorithm.
 Data from high-rate processing for SOCRATES research flight 1, 4:10:00
 -- 5:00:00 UTC.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DataP <- DataHR[setRange(DataHR, 41000, 50000),]
\end_layout

\begin_layout Plain Layout

layout(matrix(1:3, ncol=1), widths = 1, heights = c(5,5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

with(DataP, plotWAC(data.frame(Time, WDTC, WDG, WDC), ylab='wind direction
 [deg.]', legend.position='topright'))
\end_layout

\begin_layout Plain Layout

with(DataP, plotWAC(data.frame(Time, WSTC, WSG, WSC), ylab='wind speed [m/s]',
 legend.position='topright'))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

WIC <- SmoothInterp(DataP$WIC)
\end_layout

\begin_layout Plain Layout

WITC <- SmoothInterp(DataP$WITC)
\end_layout

\begin_layout Plain Layout

WIG <- SmoothInterp(DataP$WIG)
\end_layout

\begin_layout Plain Layout

WIY <- SmoothInterp(DataP$WIY)
\end_layout

\begin_layout Plain Layout

plotWAC(data.frame(DataP$Time, WITC, WIG, WIC, WIY), ylab='vertical wind
 [m/s', ylim=c(-2,2), legend.position='topright') 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<HRUVplots, include=TRUE, echo=FALSE, fig.cap='The lateral (VY) and longitudinal
 (UX) components of the horizontal wind for the same period shown in the
 previous figure.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

layout(matrix(1:2, ncol=1), widths=1, heights=c(5,6))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(2,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

with(DataP, plotWAC(data.frame(Time, UXTC, UXG, UXC), ylab='long.
 component [m/s]'))
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1)
\end_layout

\begin_layout Plain Layout

with(DataP, plotWAC(data.frame(Time, VYTC, VYG, VYC), ylab='lateral component
 [m/s]'))
\end_layout

\begin_layout Plain Layout

layout(matrix(1:1, ncol=1), widths=1, heights=5)
\end_layout

\begin_layout Plain Layout

op <- par (mar=c(5,4,1,1)+0.1, oma=c(1.1,0,0,0))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Removing spikes
\end_layout

\begin_layout Standard
Spikes are a prevalent problem in the high-rate data from SOCRATES flight
 #1, and they will add significant noise to the measured variance spectra,
 so their removal is an important requirement before the spectra are constructed.
 The method used is in 
\begin_inset Quotes eld
\end_inset

removeSpikes.R
\begin_inset Quotes erd
\end_inset

 that is soon to be added to the Ranadu package but for now is a separate
 file in the 
\begin_inset Quotes eld
\end_inset

Ranadu/NewWork
\begin_inset Quotes erd
\end_inset

 directory.
 The algorithm used is to calculate a rolling mean and rolling standard
 deviation for the supplied variable, set any measurements that depart from
 the rolling mean by more than 
\begin_inset Quotes eld
\end_inset

sdLimit
\begin_inset Quotes erd
\end_inset

 standard deviations (default value is sdLimit=4) as missing, and then interpola
te to fill in missing values.
 This removes most of the visibly obvious spikes, but whatever causes the
 spikes may also produce lower-amplitude fluctuations that are not removed
 by this algorithm, so it is important to determine the source of the spikes.
 This is unresolved at present (at least to the author's knowledge).
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<removeSpikes, include=TRUE, echo=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Var <- c('WIC', 'WIY', 'WIG', 'WITC', 'UXC', 'VYC', 'UXG', 'VYG', 'UXTC',
 'VYTC', 'TASX', 'TASG', 'TASTC')
\end_layout

\begin_layout Plain Layout

for (V in Var) {
\end_layout

\begin_layout Plain Layout

  DataP[,V] <- removeSpikes(DataP[,V], sdLimit=4)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Lateral variance spectra
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<VYspecHR, include=TRUE, echo=FALSE, fig.cap='Variance spectra for measurements
 of the lateral horizontal wind from SOCRATES flight 1, 4:10:00 -- 5:00:00,
 a region with some mild turbulence.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- VSpec(DataP, 'VYC', smoothBins=50)
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataP, 'VYG', smoothBins=50, ADD=g)
\end_layout

\begin_layout Plain Layout

VSpec(DataP, 'VYTC', smoothBins=50, ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<WIspecHR, include=TRUE, echo=FALSE, fig.cap='Variance spectra for measurements
 of the vertical wind from SOCRATES flight 1, for the same region as the
 previous figure.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- VSpec(DataP, 'WIC', smoothBins=50)
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataP, 'WIG', smoothBins=50, ADD=g)
\end_layout

\begin_layout Plain Layout

VSpec(DataP, 'WITC', smoothBins=50, ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VYspecHR}
\end_layout

\end_inset

 shows the three measurements of the spectral variance
\begin_inset Foot
status open

\begin_layout Plain Layout
The orange lines indicate the expected -2/3 slope for the frequency-weighted
 spectrum, with factor-of-ten difference in the corresponding eddy dissipate
 rate between successive lines.
 The heavy dotted line corresponds to an eddy dissipation rate of 
\begin_inset Formula $10^{-4}\,\mathrm{m}^{2}\mathrm{s}^{-3}$
\end_inset

.
 In plots of the longitudinal spectrum (as below for UX), the reference
 lines are adjusted for the expected 4/3 ratio between longitudinal and
 lateral spectra.
\end_layout

\end_inset

 of the lateral horizontal wind component 
\begin_inset Quotes eld
\end_inset

VY
\begin_inset Quotes erd
\end_inset

.
 All three are reasonable and VYC and VYTC (the standard variable and that
 based on the pitot-static airspeed) are consistent, but there appears to
 be some deficit in the spectral variance for VYG around 0.3
\begin_inset space ~
\end_inset

Hz.
\begin_inset Foot
status open

\begin_layout Plain Layout
A conjecture is that, because this is a frequency where the aircraft responds
 strongly to changes in airflow, there might be some residual effect on
 airflow distortion in this frequency range that dampens the response to
 real sideslip fluctuations.
\end_layout

\end_inset

 All are in reasonable agreement above 1 Hz.
 For the vertical wind (also a lateral component and so expected to show
 the same spectral variance as VY), the spectra are shown in Fig.\SpecialChar softhyphen

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:WIspecHR}
\end_layout

\end_inset

.
 The spectrum from the gust pod (variable WIG) is significantly below that
 from the other two measurements for frequencies about about 0.3
\begin_inset space ~
\end_inset

Hz and is significantly different from the spectral variance of VY in this
 region, so it appears to be suspect.
 The airflow distortions may suppress response to vertical wind at high
 frequency.
 This result differs from that in project DEEPWAVE, where the spectral variance
 of the vertical wind appeared to be very good and consistent with the spectrum
 of VY\SpecialChar endofsentence
 The major difference in aircraft configuration is the presence of
 the large pods in SOCRATES, so it may be that the resulting airflow distortion
 interferes with the ability of the gust pod to measure high-frequency component
s of the vertical wind.
 The other two measurements of vertical wind (WIY and WITC) appear to be
 too high for frequencies above about 3 Hz, and this apparent problem is
 still greater without spike removal.
 The spectrum for WIC is the same.
 This is an unfortunate weakness in the measurements, and this extended
 effort to use the new measurements has not produced an improvement in the
 vertical wind.
 The departure from expected shape above 3 Hz does not appear to be a simple
 random-noise spectrum, which would be expected to increase linearly with
 frequency in this plot, so it is unclear what causes the departure from
 expected shape.
 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<highTurb, include=TRUE, echo=FALSE, fig.cap='Variance spectra for lateral
 wind components (WI=vertical and VY=starboard) for the period from 4:56:00
 -- 5:01:00 UTC on SOCRATES flight 8.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DX8 <- getNetCDF(sprintf('%s%s/%srf08h.nc', Directory, Project, Project),
 VR, 43500, 52500)
\end_layout

\begin_layout Plain Layout

## remove some spikes
\end_layout

\begin_layout Plain Layout

VS <- c('PSTF', 'QCTF', 'UXC', 'VYC', 'TASX', 'PSXC', 'QC_GP')
\end_layout

\begin_layout Plain Layout

for (V in VS) {
\end_layout

\begin_layout Plain Layout

  DX8[, V] <- removeSpikes(DX8[, V], sdLimit=3)
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DX8 <- AddWind (DX8)
\end_layout

\begin_layout Plain Layout

DT <- DX8[setRange(DX8, 45600, 50100), ]
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'WIC', method='MEM')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'VYC', method='MEM', ADD=g)
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'VYG', method='MEM', ADD=g)
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'WIG', method='MEM', ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

rm('DT')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The turbulence is relatively mild in this region, with representative eddy
 dissipation rate of about 
\begin_inset Formula $10^{-5}\,\mathrm{m}^{2}\thinspace\mathrm{s^{-3}}$
\end_inset

.
 More turbulent regions lead to spectra with different characteristics and
 different problems.
 A good example is Flight #8, 4:56:00 – 5:01:00, where the estimated eddy
 dissipation rate is about 
\begin_inset Formula $2\times10^{-3}\mathrm{m}^{2}\thinspace\mathrm{s}^{-3}$
\end_inset

.
 In this case, both standard lateral spectra (for WIC and VYC, blue and
 green lines in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:highTurb}
\end_layout

\end_inset

) appear very good and consistent with each other, without the suspicious
 flattening evident in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:WIspecHR}
\end_layout

\end_inset

.
 Also in other cases examined in SOCRATES, these lateral variance spectra
 show the expected high-frequency slope and there are no evident problems.
 Variance spectra for other related variables WIY, WITC, VYTC are not distinguis
hable from those for WIC and VYC.
 However, the gust-pod measurements continue to have problems at high frequency.
 The spectrum for the vertical wind (WIG, brown line) is lower than the
 other measurements, has apparent low intensity at high frequency, and is
 generally not in agreement with other measurements for frequencies above
 about 0.3
\begin_inset space ~
\end_inset

Hz.
 Effects of flow distortion around the aircraft apparently affect the ability
 of this instrument to measure high-frequency fluctuations in the vertical
 wind.
 The gust-pod measurement of lateral wind, VYG, looks better but too high
 for frequencies above about 3
\begin_inset space ~
\end_inset

Hz.
\end_layout

\begin_layout Subsection
Longitudinal variance spectra
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<UXspecHR, include=TRUE, echo=FALSE, fig.cap='Variance spectra similar to
 those shown in the previous two plots and for the same time interval, but
 for the longitudinal spectrum UX.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

g <- VSpec(DataP, 'UXC', ae=0.15, smoothBins=50)
\end_layout

\begin_layout Plain Layout

g <- VSpec(DataP, 'UXG', smoothBins=50, ADD=g)
\end_layout

\begin_layout Plain Layout

VSpec(DataP, 'UXTC', smoothBins=50, ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Similar plots of spectral variance for the longitudinal components (UX)
 are shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:UXspecHR}
\end_layout

\end_inset

, for same time period for which the lateral spectra were shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:VYspecHR}
\end_layout

\end_inset

.
 In this case (with moderately low turbulence), the gust-pod measurements
 appear to be biased upward with a high-frequency slope characteristic of
 noise for frequencies above about 1
\begin_inset space ~
\end_inset

Hz.
\begin_inset Foot
status open

\begin_layout Plain Layout
The calculation of airspeed used the same decomposition into fast and slow
 components as for angles of attack and sideslip, except with a cutoff frequency
 at 1/60
\begin_inset space ~
\end_inset

Hz to try to improve the high-frequency response, but that did not improve
 the variance spectra relative to a fit that did not use this decomposition.
\end_layout

\end_inset

 For this measurement, the pitot-static measurement of airspeed has produced
 a significantly better spectral variance for the frequency range above
 1
\begin_inset space ~
\end_inset

Hz, but even that spectrum shows some flattening above about 4\SpecialChar softhyphen
Hz.
 This may be a residual effect of whatever is causing the frequent spikes
 in the measurements from this flight or it may result from high-frequency
 flow-distortion effects in the airflow approaching the pitot-static sensor,
 which is close to the aircraft skin.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<longSpecGP, include=TRUE, echo=FALSE, fig.cap='Variance spectra for a region
 of more intense turbulence, for the longitudinal wind component (UX).
 UXC is the standard measurement, UCTC is based on the airspeed measured
 by the pitot-static sensor, and UXG is from the gust pod.
 Data from SOCRATES research flight 8, 4:56:00 -- 5:01:00 UTC.'>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DT <- DX8[setRange(DX8, 45600, 50100), ]
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'UXG', ae=0.15, method='MEM')
\end_layout

\begin_layout Plain Layout

g <- VSpec(DT, 'UXC', method='MEM', ADD=g)
\end_layout

\begin_layout Plain Layout

VSpec(DT, 'UXTC', method='MEM', ADD=g) + theme_WAC()
\end_layout

\begin_layout Plain Layout

rm('DT')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For the case with high-intensity turbulence, for which lateral spectra were
 shown in Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:highTurb}
\end_layout

\end_inset

, Fig.
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{fig:longSpecGP}
\end_layout

\end_inset

 shows the variance spectrum for measurements of the longitudinal component.
 The standard measurement (UXC, green line) produces estimates of spectral
 density that depart from the expected slope above about 1
\begin_inset space ~
\end_inset

Hz, reflecting the problem arising from sample-line resonance discussed
 before.
 The new measurement from the pitot-static sensor (UXTC) looks much better
 but still shows indications of noise beginning around 5
\begin_inset space ~
\end_inset

Hz.
 For the gust pod (blue line), two features are notable, the 0.5-Hz peak
 and the apparently good performance near the Nyquist limit.
 The former is probably an erroneous effect of the flow-distortion around
 the aircraft and some coupling of that to natural oscillations of the aircraft
 in pitch and heading.
 The latter effect suggests that, if it becomes crucial to some aspect of
 research, it may be feasible to 
\begin_inset Quotes eld
\end_inset

blend
\begin_inset Quotes erd
\end_inset

 the high-frequency measurements from the gust pod with the lower-frequency
 components of the pitot-static-based measurement of longitudinal wind.
 
\end_layout

\begin_layout Standard
The longitudinal spectra would look much worse without the spike-removal
 procedure discussed in the preceding section, so some of the remaining
 problem may arise from smaller spikes not removed by that algorithm.
 This is another indication that it is important to find and correct the
 source of those spikes, which have been prevalent during SOCRATES.
\end_layout

\begin_layout Section
Summary and Conclusions
\end_layout

\begin_layout Standard
The NCAR Technical Note TN-528+STR (
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2016ncartn"

\end_inset

) indicated that the estimated standard uncertainty for measurements of
 wind from the NSF/NCAR GV research aircraft are about 0.12
\begin_inset space ~
\end_inset

m/s for the vertical wind and 0.4
\begin_inset space ~
\end_inset

m/s for each component of the vertical wind, but it also discussed a problem
 with measurements of the variance spectrum of the longitudinal component
 of the wind (i.e., along the aircraft longitudinal axis) at frequencies above
 about 1
\begin_inset space ~
\end_inset

Hz.
 The present report extends that study in these ways:
\end_layout

\begin_layout Enumerate
Measurements from the LAMS were used to confirm that the corrections being
 applied to measurements of ambient and dynamic pressure remained valid
 in Feb.
\begin_inset space ~
\end_inset

2017, at the time of the ARISTO-2017 campaign.
\end_layout

\begin_layout Enumerate
Prior to Feb.
\begin_inset space ~
\end_inset

2017, a new pitot-static sensor was installed on the GV, largely as a result
 of Dick Friesen's initiative.
 The purpose was to reduce the contamination of the longitudinal-wind measuremen
t that results from resonance in the sample lines.
 That sensor was recorded in SOCRATES, so in this report a processing scheme
 was developed to use with that sensor.
 New measurements of the wind were then calculated using the revised airspeed
 from that sensor.
 The conclusion of an evaluation of those wind measurements is that:
\end_layout

\begin_deeper
\begin_layout Enumerate
At low rate (<0.5 Hz) the measurement of airspeed and hence of wind is consistent
 with the standard system.
 This result did not rely on any calibration to match the standard system
 because the pitot-static tube provides an independent measurement of the
 total pressure (ambient plus dynamic) that agrees with the standard system
 without calibration.
 
\end_layout

\begin_layout Enumerate
At high rate (>0.5 Hz) the variance spectrum of the airspeed or the longitudinal
 component of the wind is in better agreement with the expected -5/3 slope
 up to about 5
\begin_inset space ~
\end_inset

Hz, but above that frequency some noise is still present in the spectrum.
 The source of this residual noise has not been determined.
 Despite that deficiency, the longitudinal variance spectrum has been improved
 significantly by the addition of the pitot-static tube, and future data
 processing should be based on the dynamic pressure from that sensor.
\end_layout

\begin_layout Enumerate
A separate memo (attached) describes how the measurements from the pitot-static
 sensor can be incorporated into the standard processing for the GV\SpecialChar endofsentence
 A processing
 scheme to add the new measurements based on the pitot-static sensor has
 been added to the QAtools shiny app.
 For low-rate measurements the new algorithm is trivially simple and can
 be incorporated immediately into standard processing.
 At high rate, it is helpful to apply some filtering to one of the variables
 used, so that may be done best in post-processing for now, although the
 low-rate algorithm could also be used and would usually produce an improvement
 even at high rate.
\end_layout

\end_deeper
\begin_layout Enumerate
The gust pod (based on an 858 probe mounted in a canister under the GV wing)
 was flown in SOCRATES for the first time in conjunction with the large
 underwing pods.
 They apparently changed the airflow distortion ahead of the gust pod so
 that the earlier processing scheme led to some offsets in the measurements
 (for example changing the airspeed calculation by 2 m/s).
 Therefore a new procedure was developed for using the gust pod in this
 configuration.
 That procedure then was used to calculate wind measurements from the gust
 pod that are mostly independent of those from the radome-based system.
 These are the significant results from study of those measurements of wind
 from the gust pod:
\end_layout

\begin_deeper
\begin_layout Enumerate
At low rate, measurements of airspeed and of the angles of attack and sideslip
 were consistent with measurements from the standard system, so the gust
 pod provides a useful all-weather backup to that system.
\end_layout

\begin_layout Enumerate
The variance spectra for measurements from the gust pod showed various problems
 that appear associated with airflow distortion.
 There appears to be possible contamination of the longitudinal-wind spectrum
 at frequencies expected for phugoidal or Dutch-roll aerodynamic instabilities.
 These are removed by the standard measuring system, but the distortion
 of airflow around the aircraft may be delayed in ways that could affect
 the airflow at the gust pod.
 Although this is a conjecture, there is a clear problem at around 5 Hz
 in the longitudinal-wind spectrum from the gust pod.
 The spectral density for the vertical-wind seems significantly too low
 at high frequency.
 The suggested conclusion is that measurements from the gust pod do not
 lead to useful estimates of spectral variance.
\end_layout

\begin_layout Enumerate
A processing scheme was developed to produce measurements of the wind vector
 and the airspeed from the variables that the gust pod measures.
 It appears to be too complex to be worth incorporating into the standard
 processor 
\begin_inset Quotes eld
\end_inset

nimbus
\begin_inset Quotes erd
\end_inset

 because, to get useful measurements, it was necessary to use various transforma
tions among coordinate systems and fitting to measurements that are split
 into complementary low-frequency and high-frequency components.
 A processor to add the wind measurements from the gust pod to the standard
 netCDF files has been incorporated into the QAtools shiny app.
\end_layout

\end_deeper
\begin_layout Enumerate
In the 25-Hz netCDF files produced during the field project, there are spikes
 in many of the measurements that do not appear to be real and that, unless
 removed, will contaminate the variance spectra for those measurements.
 For the plots of spectral variance shown in Sect.
\begin_inset space ~
\end_inset

5 of this report a spike-removal algorithm was used to reduce the effects
 of such spikes, but other spikes of lower amplitude may remain and contaminate
 the spectra.
 Follow-up investigation is needed to determine the source of these spikes.
\end_layout

\begin_layout Section
The Processor
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<nVarCalc, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Project <- 'SOCRATES'
\end_layout

\begin_layout Plain Layout

Flight <- 1
\end_layout

\begin_layout Plain Layout

fname <- sprintf ('%s%s/%srf%02d.nc', Directory, Project, Project, Flight)
\end_layout

\begin_layout Plain Layout

fnew <- sub ('.nc', 'Y.nc', fname)
\end_layout

\begin_layout Plain Layout

Z <- file.copy (fname, fnew, overwrite=TRUE)  ## BEWARE: overwrites without
 warning!!
\end_layout

\begin_layout Plain Layout

## read variables needed for the calculation
\end_layout

\begin_layout Plain Layout

FI <- DataFileInfo (fname, LLrange=FALSE)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## for some old projects:
\end_layout

\begin_layout Plain Layout

if (!('GGVSPD' %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

  if ('GGVSPDB' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VR [which (VR == 'GGVSPD')] <- 'GGVSPDB'
\end_layout

\begin_layout Plain Layout

  } else if ('VSPD_A' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VR [which (VR == 'GGVSPD')] <- 'VSPD_A'
\end_layout

\begin_layout Plain Layout

  } else if ('VSPD_G' %in% FI$Variables) {
\end_layout

\begin_layout Plain Layout

    VR [which (VR == 'GGVSPD')] <- 'VSPD_G'
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    print ('ERROR: no VSPD variable found')
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

for (Var in VR) {
\end_layout

\begin_layout Plain Layout

  if (!(Var %in% FI$Variables)) {
\end_layout

\begin_layout Plain Layout

    print (sprintf (' required variable %s not found in file %s; skipping...',
 Var, fname))
\end_layout

\begin_layout Plain Layout

    exit()
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

DY <- getNetCDF(fname, VR)
\end_layout

\begin_layout Plain Layout

Data <- AddWind(DY)    ## default adds everything
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<newNetCDF, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

source ('chunks/copyAttributes.R')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

netCDFfile <- nc_open (fnew, write=TRUE) 
\end_layout

\begin_layout Plain Layout

Dimensions <- attr (Data, "Dimensions")
\end_layout

\begin_layout Plain Layout

Dim <- Dimensions[["Time"]]
\end_layout

\begin_layout Plain Layout

Rate <- 1
\end_layout

\begin_layout Plain Layout

if ("sps25" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 25
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps25"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

if ("sps50" %in% names (Dimensions)) {
\end_layout

\begin_layout Plain Layout

  Rate <- 50
\end_layout

\begin_layout Plain Layout

  Dim <- list(Dimensions[["sps50"]], Dimensions[["Time"]])
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

DATT <- Data  ## save to ensure that attributes are preserved
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## variables to add to the netCDF file:
\end_layout

\begin_layout Plain Layout

VarNew <- c('AKY', 'WIY', 'AK_GP', 'SS_GP', 'WIG', 'WDG', 'WSG', 'TASG',
 'UXG', 'VYG', 'ROC', 'TASTC', 'WDTC', 'WSTC', 'WITC', 'UXTC', 'VYTC')
\end_layout

\begin_layout Plain Layout

VarOld <- c('AKRD', 'WIC', 'AKRD', 'SSRD', 'WIC', 'WDC', 'WSC', 'TASX',
 'UXC', 'VYC', 'GGVSPD', 'TASX', 'WDC', 'WSC', 'WIC', 'UXC', 'VYC') 
\end_layout

\begin_layout Plain Layout

VarUnits <- c('degrees', 'm/s', 'degrees', 'degrees', 'm/s', 'm/s', 'm/s',
 'm/s', 'm/s', 'm/s', 'm/s', 'm/s', 'degrees', 'm/s', 'm/s', 'm/s', 'm/s')
\end_layout

\begin_layout Plain Layout

VarStdName <- c('angle-of-attack, CF', 'vertical wind, CF', 'angle-of-attack,
 GP', 'sideslip angle, GP', 'vertical wind, GP', 'wind direction, GP', 'wind
 speed, GP', 'true airspeed, GP', 'wind longitudinal component, GP', 'wind
 lateral component, GP', 'rate of climb', 'true airspeed, pitot-static',
 'wind direction, pitot-static', 'wind speed, pitot-static', 'vertical wind,
 pitot-static', 'wind longitudinal component, pitot-static', 'wind lateral
 component, pitot-static')
\end_layout

\begin_layout Plain Layout

VarLongName <- c('angle of attack, complementary-filter',
\end_layout

\begin_layout Plain Layout

                 'vertical wind using comp-filter angle of attack',
\end_layout

\begin_layout Plain Layout

                 'angle of attack from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'sideslip angle from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'vertical wind from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind direction from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind speed from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'true airspeed from the gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind, longitudinal component, gustpod',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind, lateral component, gustpod',
\end_layout

\begin_layout Plain Layout

                 'rate of climb of the aircraft from pressure',
\end_layout

\begin_layout Plain Layout

                 'true airspeed from the pitot-static sensor',
\end_layout

\begin_layout Plain Layout

                 'wind direction based on the pitot-static airspeed',
\end_layout

\begin_layout Plain Layout

                 'wind speed based on the pitot-static airspeed',
\end_layout

\begin_layout Plain Layout

                 'vertical wind based on TASTC and AKY',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind, longitudinal component, pitot-static',
\end_layout

\begin_layout Plain Layout

                 'horizontal wind, lateral component, pitot-static')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

## create the new variables
\end_layout

\begin_layout Plain Layout

varCDF <- list ()
\end_layout

\begin_layout Plain Layout

for (i in 1:length(VarNew)) {
\end_layout

\begin_layout Plain Layout

  print (sprintf ('new-netcdf %d%% done', as.integer(100*(i-1)/length(VarNew))))
\end_layout

\begin_layout Plain Layout

  varCDF[[i]] <- ncvar_def (VarNew[i],  
\end_layout

\begin_layout Plain Layout

                            units=VarUnits[i], 
\end_layout

\begin_layout Plain Layout

                            dim=Dim, 
\end_layout

\begin_layout Plain Layout

                            missval=as.single(-32767.), prec='float', 
\end_layout

\begin_layout Plain Layout

                            longname=VarLongName[i])
\end_layout

\begin_layout Plain Layout

  if (i == 1) {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (netCDFfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  } else {
\end_layout

\begin_layout Plain Layout

    newfile <- ncvar_add (newfile, varCDF[[i]])
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  ATV <- ncatt_get (netCDFfile, VarOld[i])
\end_layout

\begin_layout Plain Layout

  copy_attributes (ATV, VarNew[i], newfile)
\end_layout

\begin_layout Plain Layout

  ncatt_put (newfile, VarNew[i], attname="standard_name", 
\end_layout

\begin_layout Plain Layout

             attval=VarStdName[i])
\end_layout

\begin_layout Plain Layout

  if (Rate == 1) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], Data[, VarNew[i]])
\end_layout

\begin_layout Plain Layout

  } else if (Rate == 25) {
\end_layout

\begin_layout Plain Layout

    ncvar_put (newfile, varCDF[[i]], Data[, VarNew[i]], count=c(25, nrow(Data)/2
5))
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

nc_close (newfile)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The transformations from the gust-pod reference frame to the aircraft reference
 frame are involved and likely to need careful check-out when implemented,
 so instead the recommended initial approach is to use a separate processor
 to add these variables to the netCDF files.
 This processor is included in the QAtools shiny app, under the 
\begin_inset Quotes eld
\end_inset

Special
\begin_inset Quotes erd
\end_inset

 tab, as an option in the 
\begin_inset Quotes eld
\end_inset

Options for Wind
\begin_inset Quotes erd
\end_inset

 tab.
 That tab also supports addition of wind variables based on the pitot-static
 sensor, the complementary-filter-based angle of attack and associated vertical
 wind as well as the addition of a high-pass-filtered version of the vertical
 wind.
 A new file with the suffix 
\begin_inset Quotes eld
\end_inset

Y
\begin_inset Quotes erd
\end_inset

 added to the name (e.g., SOCRATESrf01Y.nc) is created using a copy of the
 original, and these variables are added to that file:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="20" columns="3">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="left" valignment="top" width="0pt">
<column alignment="center" valignment="middle" width="3cm">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
New Variable
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Description
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Reference
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AKY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
angle-of-attack, complementary-filter algorithm
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eqns._(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-fast"

\end_inset

), (
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:alpha-slow"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WIY
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertical wind, based on AKY
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sec:Summary"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
ROC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
rate of climb of the aircraft, using hydrostatic equation
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset citation
LatexCommand citet
key "Cooper2017ncartn"

\end_inset

 (Sect.
 3.1)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AK_GP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
angle-of-attack from the gust pod, in the a-frame
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Sect.
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:Calibration-AOA"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sideslip angle from the gust pod, in the a-frame
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eqn.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:newSSG"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WIG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertical wind calculated using AK_GP and SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WDG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind direction using AK_GP and SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WSG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind direction using AK_GP and SS_GP
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TASG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
airspeed calculate from the gust-pod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eqn.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "eq:TASG"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UXG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind from the gust pod, longitudinal component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eqn.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pitot-static-algorithm"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VYG
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind from the gust pod, lateral (starboard) component
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
TASTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
airspeed calculated from the pitot-static sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Eqn.
\begin_inset space ~
\end_inset

(
\begin_inset CommandInset ref
LatexCommand ref
reference "subsec:pitot-static-algorithm"

\end_inset

)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WDTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind direction based on the pitot-static sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WSTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
wind speed based on the pitot-static sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WITC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
vertical wind based on the pitot-static sensor
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UXG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
longitudinal wind based on the gust pod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VYG
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lateral wind based on the gust pod
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UXTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
longitudinal wind component based on TASTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VYTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
lateral (starboard) wind component based on TASTC
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Instructions for running this special processor are included in the QAtools
 user guide.
 See the discussion of the 
\begin_inset Quotes eld
\end_inset

Special
\begin_inset Quotes erd
\end_inset

 tab.
 The code used for this processing is available as part of the GitHub archive
 for this report; see 
\begin_inset Quotes eld
\end_inset

WindInSocrates.Rnw
\begin_inset Quotes erd
\end_inset

 and the associated chunk 
\begin_inset Quotes eld
\end_inset

AddWind.R
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Section
\start_of_appendix
Reproducibility
\end_layout

\begin_layout Standard
This document is constructed in ways that support duplication of the study.
 The code that generates the plots and implements the processing algorithm
 is incorporated into the same file that generated this document via 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LaTeX
\end_layout

\end_inset

, using principles and techniques described by 
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014a"

\end_inset

 as implemented in the R package 'knitr' (
\begin_inset CommandInset citation
LatexCommand citet
key "Xie2014b"

\end_inset

).
 The program, 'WindInSOCRATES.Rnw', is archived on 'GitHub' in the directory
 at 
\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "https://github.com/WilliamCooper/SocratesQA.git"

\end_inset

.
 There is some supplemental material in that directory, including the workflow
 document, the bibliography and some code segments saved in the 
\begin_inset Quotes eld
\end_inset

chunks
\begin_inset Quotes erd
\end_inset

 subdirectory.
 This full directory should be downloaded in order to run the program.
 The calculations use the programming language R (
\begin_inset CommandInset citation
LatexCommand citet
key "Rlanguage"

\end_inset

) and were run within RStudio (
\begin_inset CommandInset citation
LatexCommand citet
key "RStudio2012"

\end_inset

), so this is the most straightforward way to replicate the calculations
 and the generation of this document.
\end_layout

\begin_layout Standard
A package named Ranadu, containing ancillary functions, is used extensively
 in the R code.
 It is available on GitHub as 
\begin_inset CommandInset href
LatexCommand href
target "https://github.com/WilliamCooper/Ranadu.git"

\end_inset

.
 The version used for calculations in this technical note is included in
 the 'zip' archive listed below.
\end_layout

\begin_layout Standard
The original files containing the data as produced by the NCAR Earth Observing
 Laboratory, Research Aviation Facility, were in netCDF format (cf.
\begin_inset space ~
\end_inset


\begin_inset CommandInset href
LatexCommand href
name "this URL"
target "http://www.unidata.ucar.edu/software/netcdf/"

\end_inset

), but particularly for SOCRATES the files used are preliminary data not
 yet released for general use.
 The officially released data files should be used once they are available.
 The subset data frames constructed from those preliminary netCDF files
 are saved and can be provided by the author, if or when that is consistent
 with the project data policies.
 The code in the GitHub archive has appropriate 'load' commands to read
 these data files from a subdirectory named 'Data' (/Data or ~/Data or /home/Dat
a) but this is not part of the GitHub repository because it is too large
 to be appropriate there.
 To reproduce this research, those data files have to be transferred separately
 from the NCAR HPSS to the 'Data' directory.
 Some use has been made of attributes assigned to the data.frames and the
 variables in those data.frames.
 All the attributes from the original netCDF files have been transferred,
 so there is a record of how the original data were processed, for example
 recording calibration coefficients and processing chains for the variables.
 Once the data.frames are loaded into R, these attributes can be viewed and
 provide additional documentation of what data were used.
 Key information like the processing date, the program version that produced
 the archive, and the selection of primary variables for various measurements
 thus is preserved.
\end_layout

\begin_layout Standard
(See the related list of project components on the next page.)
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Project:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
WindInSOCRATES
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Archive package:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WindInSOCRATES.zip"
target "https://github.com/WilliamCooper/GustPod/blob/master/AddingGustPodSocrates.zip"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Contains:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
attachment list below
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Program:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WindInSOCRATES.Rnw"
target "https://github.com/WilliamCooper/GustPod/blob/master/WindInSOCRATES.Rnw"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Special Data Files:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
AKRDdata.Rdata
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Workflow Document:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "WorkflowWindInSOCRATES.pdf"
target "https://github.com/WilliamCooper/GustPod/blob/master/WorkflowWindInSOCRATES.pdf"

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family sans
\shape smallcaps
\color blue
Git:
\family default
\shape default
\color inherit
 
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset CommandInset href
LatexCommand href
name "https://github.com/WilliamCooper/SocratesQA.git"
target "https://github.com/WilliamCooper/SocratesQA.git"

\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
attachm{
\end_layout

\end_inset

WindInSOCRATES.Rnw
\begin_inset Newline newline
\end_inset

WindInSOCRATES.pdf
\begin_inset Newline newline
\end_inset

NoteReSOCRATESwindProcessing.pdf
\begin_inset Newline newline
\end_inset

WorkflowWindInSOCRATES.pdf
\begin_inset Newline newline
\end_inset

WAC.bib
\begin_inset Newline newline
\end_inset

chunks/*
\begin_inset Newline newline
\end_inset

SessionInfo
\begin_inset ERT
status collapsed

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
phantomsection 
\backslash
addcontentsline{toc}{section}{References}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sec:bibliography"

\end_inset

 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "WAC"
options "plainnat"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
centerline{-- Blank Page, End of this Technical Report --}
\end_layout

\begin_layout Plain Layout


\backslash
vfill
\backslash
eject
\end_layout

\begin_layout Plain Layout


\backslash
clearpage
\end_layout

\begin_layout Plain Layout

%
\backslash
addcontentsline{toc}{section}{End}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

<<make-zip-archive, INCLUDE=TRUE, eval=FALSE>>=
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

cat (toLatex(sessionInfo()), file="SessionInfo") 
\end_layout

\begin_layout Plain Layout

system (sprintf("zip WindInSOCRATES.zip WindInSOCRATES.Rnw WindInSOCRATES.pdf
 NoteReSOCRATESwindProcessing.pdf WorkflowWindInSOCRATES.pdf WAC.bib ./chunks/*
 SessionInfo"))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@ 
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vskip0.5truein 
\backslash
centerline{
\backslash
textcolor{blue}{---- END ----}}
\end_layout

\end_inset


\end_layout

\end_inset


\begin_inset Note Note
status open

\begin_layout Plain Layout
this is just a closing line to note end of the memo
\end_layout

\end_inset


\end_layout

\end_body
\end_document
