%% LyX 2.3.0 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[12pt,english]{article}
\usepackage{mathptmx}
\usepackage[T1]{fontenc}
\usepackage[letterpaper]{geometry}
\geometry{verbose,tmargin=3.54cm,bmargin=2.54cm,lmargin=2.54cm,rmargin=2.54cm,headheight=1cm,headsep=2cm,footskip=0.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\setcounter{secnumdepth}{2}
\setcounter{tocdepth}{2}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
%% Because html converters don't know tabularnewline
\providecommand{\tabularnewline}{\\}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\input colordvi
\usepackage{color}
\fancyhead{}
\fancyfoot[CE,CO]{}
\newtoks{\addressee} \global\addressee={}
\newdimen\longindent \longindent=3.5truein
\fancyhead[L]{Memo to: \the\addressee \\ \datetoday \\ Page \thepage \hfill}
\renewcommand{\headrulewidth}{0.0pt}
\newenvironment{lyxlist}[1]
{\begin{list}{}
{\settowidth{\labelwidth}{#1}
\setlength{\leftmargin}{\labelwidth}
\addtolength{\leftmargin}{\labelsep}
\renewcommand{\makelabel}[1]{##1\hfil}}}
{\end{list}}
\newcommand{\datetoday}{\number\day\space
     \ifcase\month\or January\or February\or March\or April\or May\or
     June\or July\or August\or September\or October\or November\or
     December\fi
     \space\number\year}
\newcommand{\EOLmemo}{\null \vskip-1.5truein
{\raggedright \textsf{\textsc{\large \textcolor{blue}{Earth Observing Laboratory}}}}\par
{\raggedright \textsf{\textsl{\textcolor{blue}{Memorandum:}}}} \par \vskip6pt
{\color{blue}{\hrule}}\par
\vskip0.3truein \leftline{\hskip \longindent \datetoday} \vskip0.2truein
\thispagestyle{empty}}
\newcommand{\attachm}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachments:] {#1}
\end{lyxlist}}
\newcommand{\cc}[1]{\begin{lyxlist}{Attachments:00}
\item [cc:] {#1}
\end{lyxlist}}
\newcommand{\attach}[1]{\begin{lyxlist}{Attachments:00}
\item [Attachment:] {#1}
\end{lyxlist}}
%usage: \encl{A\\B\\C} or \cc{ma,e1\\name2\\name3}

\makeatother

\usepackage{babel}
\begin{document}
\EOLmemo 

\global\addressee={"Variance Spectra" file}  % >>change "File" to the "To:" name desired

\begin{tabular}{ll}
\textsf{\textsc{\textcolor{blue}{To:}}} & \the\addressee\tabularnewline
\textsf{\textsc{\textcolor{blue}{From:}}} & Al Cooper\tabularnewline
\textsf{\textsc{\textcolor{blue}{Subject:}}} & Simulation of -5/3 variance spcetra\tabularnewline
\end{tabular}

\bigskip

<<initialization,echo=FALSE,include=FALSE>>=


library(knitr)
opts_chunk$set(echo=FALSE, include=FALSE, fig.lp="fig:")
opts_chunk$set(fig.width=6, fig.height=5, fig.align="center", digits=4)
thisFileName <- "InertialSubrangeSimulation"
require(Ranadu, quietly = TRUE, warn.conflicts=FALSE)
require(ggplot2)
require(grid)
require(ggthemes)
require(scales)
source('~/RStudio/Ranadu/R/makeNetCDF.R')    ## pending update to Ranadu
Directory <- DataDirectory ()
Flight <- 1 				
Project = "SOCRATES"			
ProjectDir <- "SOCRATES"
fname = sprintf("%s%s/%srf%02d.nc", Directory, ProjectDir, Project, Flight)
# Data <- getNetCDF (fname, standardVariables(c("WIC")))		#XXX set variables needed here
SaveRData <- sprintf("%s.Rdata", thisFileName)

@

\section*{The Goal}

To evaluate methods of spectral analysis and the effects of various
sampling and interpolation strategies, it would be useful to have
a time series generated so that it produces the -5/3 slope, relationship
to eddy dissipation rate, and isotropy expected for an inertial subrange.
This code generates such time series of duration T by combining sine-wave
components with frequencies spanning the components in the available
time series (i.e., from 1/T to the Nyquist frequency $f_{n}$), with
amplitudes weighted to produce the desired slope and specified eddy
dissipation rate. The generated series is saved in a netCDF file named
EDRseries50Hz.nc, of duration 30 min and sample rate 50 Hz. Other
sample rates and eddy dissipation rates can be generated by adjusting
``Rate'' and ``epsilon'' in this script. The output variables
are named 'u', 'v', and 'w' in the netCDF file, and normalization
conventions are used so that the longitudinal component ('u') has
spectral variance 3/4 that of the other two transverse wind components.
The netCDF file also contains a variable 'TASX', set to a constant
200, because some functions for spectral analysis including Ranadu::VSpec
expect such a variable.

\section*{The Desired Variance Spectrum}

The variance spectrum expected for an inertial subrange has the following
form:\\
\begin{equation}
P(\nu)=C\left(\frac{2\pi}{V}\right)^{-2/3}\epsilon^{2/3}\nu^{-5/3}\label{eq:expectedSpectrum}
\end{equation}
where $C=0.5$ for the longitudinal component of the wind and 2/3
for a lateral component. For an eddy dissipation rate of $10^{-4}\,\mathrm{m}^{2}\mathrm{s^{-3}}$and
a flight speed of $V=200$~m/s, the resulting spectrum for a lateral
wind component is shown in Fig.~\ref{fig:varSpec}.\footnote{. One way to generate a time series of duration $T$ and a specified
eddy dissipation rate that has this spectrum might be to start with
the periodigram corresponding to (1), for frequencies from $1/T$
to the Nyquist frequency for the desired sample rate amd then Fourier
transform the result from frequency to time. This gives a unique result
that is unrealistic because the variance is concentrated at the two
ends of the time series. Therefore the alternate approach in the next
section will be used.}

<<varSpec, include=TRUE, echo=TRUE, fig.cap="Assumed spectral variance at periodogram points.">>=

epsilon <- 1.e-5  ## mks
e23 <- epsilon^(2/3)
V <- 200   ## assumed flight speed, m/s
duration <- 1800
Rate <- 50
Nyq <- Rate / 2
C <- (2/3) * (2*pi/V)^(-2/3)
# freq <- seq(1/duration, Nyq, by=1/duration)  ## unaliased version
freq <- seq(1/duration, Nyq*5, by=1/duration)
p <- C * e23 * freq^(-5/3)  ## this is variance per frequency interval, normalized to be positive frequencies
r <- freq > 0 & freq <= Nyq
plot(freq[r], p[r], type='l', log='xy', xlab='frequency [Hz]', ylab='P(frequency) [m^2 / (s^2 Hz)]', col='blue', lwd=2)

@

\section*{Generating the Time Series}

<<generate, include=TRUE, echo=TRUE, fig.cap='The variance spectrum of the generated time series, with aliasing.'>>=

Time <- seq(0, duration * Rate - 1) / Rate
u <- v <- w <- rep(0, length(Time))
nf <- length(freq)
rnu <- runif(nf); rnv <- runif(nf); rnw <- runif(nf)
a <- sqrt(2*p / duration)   ## 2 for normalization convention
for (i in 1:nf) {
  fT <- freq[i] * Time
  u <- u + sqrt(3/4) * a[i] * sin(2*pi * (fT + rnu[i]))  ## random phase
  v <- v + a[i] * sin(2*pi * (fT + rnv[i]))
  w <- w + a[i] * sin(2*pi * (fT + rnw[i]))
}

DF <- data.frame(Time=Time, TASX=rep(V, length(Time)), u=u, v=v, w=w)
attr(DF, 'Rate') <- Rate
g <- VSpec(DF, 'w', xlim=c(0.01,30))
g <- VSpec(DF, 'v', ADD=g)
VSpec(DF, 'u', ADD=g) + theme_WAC()
g <- VSpec(DF, 'w', xlim=c(0.01,30), type='MEM')
## now filter and reduce rate to Rate2
Rate2 <- 25
Time2 <- seq(0, duration * Rate2 - 1) / Rate2
wf <- signal::decimate(w, Rate/Rate2, n=100, ftype='fir')
DF2 <- data.frame(Time=Time2, TASX=rep(V, length(Time2)), wf=wf)
attr(DF2, 'Rate') <- Rate2
## save this for plotting below
gf <- VSpec(DF2, 'wf', VLabel='filtered w', type='MEM', ADD=g) + theme_WAC()

@

The generation of an appropriate time series then follows these steps:
\begin{enumerate}
\item Define a duration and sample rate (here 1800 s and 50 Hz).
\item Initialize a time series $t$ of length 'duration {*} Rate', initially
all zero, and a corresponding 'Time' variable in the interval (0,duration)
with increments of 1/Rate. 
\item Define an appropriate set of frequencies in the interval (1/duration,
Rate/2), each spaced 1/duration from the last. The upper limit is
the Nyquist frequency for the assumed sample rate. Alternately, extend
the interval to five times the Nyquist frequency to incorporate the
effect of aliasing.
\item For each frequency $f$:
\begin{enumerate}
\item generate a sine wave with this frequency and random phase, using $\sin(2\pi(f*\mathrm{Time}+r)$
where $r$ is a random number uniformly distributed between 0 and
1.
\item Multiply the time series by the following normalization constant A
and add it to t:
\begin{enumerate}
\item The variance of each sine wave in the time series is Var=$A^{2}<\sin^{2}(...)>\,=\,0.5A^{2}$, 
\item The desired variance per frequency is $p$. Therefore $p=0.5A^{2}T$
where $T$ is the duration of the time series in seconds. The factor
arises because there are $T$ different frequencies contributing to
each unit frequency interval. 
\item Therefore $A=\sqrt{2p/T}$.
\end{enumerate}
\end{enumerate}
\item Save the resulting time series $t$ and corresponding Time variable
to a data.frame, and add TASX=200 to the data-frame for convenience
because it is expected in some spectral-analysis programs like Ranadu::VSpec.
Also save the ``Rate'' attribute with the data.frame.
\end{enumerate}
The result for one realization of the time series is shown in Fig.~\ref{fig:generate}.
The match to the assumed eddy dissipation rate ($10^{-5}m^{2}s^{-3})$
is good. This time series can then be written to a netCDF file (preferably
with the Time variable converted to RAF convention) to use as input
to studies of how missing values and other problems will affect the
resulting variance spectrum. Because the amplitude of the variations
is proportional to $\epsilon^{1/3}$, a time series for a different
eddy dissipation rate can be obtained by scaling these by ($\epsilon^{\prime}/\epsilon^{*})^{1/3}$
where $\epsilon^{\prime}$ is the desired eddy dissipation rate and
$\epsilon^{*}$ is $10^{-5}\,\mathrm{m}^{2}\mathrm{s}^{-3}$.

<<makeNetCDF, include=TRUE, echo=TRUE>>=

source('~/RStudio/Ranadu/R/makeNetCDF.R')
load('Time_units.Rdata')
attr(DF$Time, 'units') <- Time_units$value
tref <- sub ('seconds since ', '', attr (DF$Time, 'units'))
DF$Time <- as.POSIXct(DF$Time, tz='UTC', origin=tref)
load('dim.Rdata')
if (Rate == 1) {
  attr(DF, 'Dimensions') <- dim1
} else if (Rate == 25) {
  attr(DF, 'Dimensions') <- dim25
} else if (Rate == 50) {
  attr(DF, 'Dimensions') <- dim50
}
attr(DF$Time, 'strptime_format') <- "seconds since %F %T %z"
Start <- as.POSIXlt (DF$Time[1])
End <- as.POSIXlt (DF$Time[nrow(.d)])
av <- sprintf("%02d:%02d:%02d-%02d:%02d:%02d", Start$hour, Start$min,
as.integer(Start$sec), End$hour, End$min, as.integer (End$sec))
attr(DF, 'TimeInterval') <- av
unlink('EDRseriesAliased.nc')
makeNetCDF(DF, 'EDRseriesAliased.nc')

@

<<decimate, include=TRUE, echo=FALSE, fig.cap='The aliased 50-Hz spectrum for w and the result after reducing the rate to 25 Hz with a length-100 FIR filter.'>>=

print (gf)

@

\section*{Filtered Output }

The generated series includes frequencies beyond the Nyquist frequency,
so aliasing appears in the variance spectra. This aliasing arises
from digitally sampled signals so electronic filters are not feasible.
The standard approach has been to ``decimate'' while using an FIR
filter to remove the aliased signal. Here, Fig.~\ref{fig:decimate}
shows the result of one approach, using the R function \emph{decimate}
to reduce the rate while applying an appropriate FIR filter.

\section*{The Effect of Spikes}

To evaluate how spikes influence the variance spectrum, the preceding
time series was modified by adding 2 to 20 randomly selected points
in the 90,000-point time series, which before this modification had
a standard deviation of approximately 1. The effect of these relatively
small spikes is dramatic, as shown in Fig.~\ref{fig:spikes}. For
comparison, the effect of adding random Gaussian noise with standard
deviation 0.05 is also shown, as the black spectrum. This plot makes
it evident that a small number of relatively small spikes can produce
significant noise in the resulting spectral variance. In another test
(not shown), a single spike in the 90,000-point time series, of magnitude
10, caused a high-frequency distortion of the time series comparable
to that produced by Gaussian noise with standard deviation 0.05. These
results emphasize the importance of removing spurious spikes from
the measurements. 

<<spikes, include=TRUE, echo=TRUE, fig.cap='Spectral variance for the generated time series before modification (blue line), after the addition of 20 spikes of magnitude 2 (green line), and with the addition of Gaussian noise having standard deviation of 0.05 (black line).'>>=

DFS <- DF
ix <- runif(20, 1, nrow(DFS))
DFS$w[ix] <- DFS$w[ix] + 2
g <- VSpec(DF, 'w', VLabel='unmodified', xlim=c(0.01,30), type='MEM')
g <- VSpec(DFS, 'w', VLabel='with spikes', type='MEM', ADD=g) 
DF$wn <- DF$w + rnorm (nrow(DF), 0, 0.05)
VSpec(DF, 'wn', VLabel='with noise', type='MEM',ADD=g) + theme_WAC()

@

\section*{The Effect of Interpolation at Missing Values}

To estimate the effect of interpolation where values are missing,
first single-time missing values were assigned to random times in
the time series for 10\% and 1\% of the 90,000 points. The routine
Ranadu::VSpec uses cubic-spline interpolation to replace the missing
values. The results are shown in Fig.~\ref{fig:missingValue}. Even
for 10\% missing, the variance spectrum is only distorted by minor
loss at the highest frequency range, and for 1\% missing the effect
is imperceptible. Figure~\ref{fig:mvDecimate} shows that, for the
resulting 25-Hz series, the effect on the variance spectrum is barely
perceptible. 

As a further test, 6-sample gaps were introduced at 2\% of the points,
with the result shown in Fig.\@.\ref{fig:mv6}. Even for this case,
the effects on the spectral variance are minor. Having substantial
numbers of missing-value points evidently does not have significant
effects on the spectral variance except at extreme (>5\%) levels.
Cubic-spline interpolation does increase the variance slightly for
frequencies around 5~Hz, however.

<<missingValue, include=TRUE, echo=TRUE, fig.cap='Effect of setting 1 percent or 10 percent of values missing.'>>=

DFM10 <- DF
DFM1 <- DF
ix10 <- runif(9000, 1, nrow(DF))
DFM10$w[ix10] <- NA
ix1 <- runif(900, 1, nrow(DF))
DFM1$w[ix1] <- NA
g <- VSpec(DF, 'w', VLabel='unmodified', xlim=c(0.01,25), type='MEM')
g <- VSpec(DFM1, 'w', VLabel='1% missing', ADD=g, type='MEM')  ## VSpec uses cubic spline interpolation
VSpec (DFM10, 'w', VLabel='10% missing', type='MEM', ADD=g) + theme_WAC()

@

<<mvDecimate, include=TRUE, fig.cap=' '>>=

gd <- VSpec(DFM10, 'w', VLabel='interpolated', xlim=c(0.01,30), type='MEM')
## now filter and reduce rate to Rate2
wi <- SmoothInterp (DF$w, .maxGap=1000*Rate2, .Length=0)
wfi <- signal::decimate(wi, Rate/Rate2, n=100, ftype='fir')
DF2 <- data.frame(Time=Time2, TASX=rep(V, length(Time2)), wf=wfi)
attr(DF2, 'Rate') <- Rate2
## save this for plotting below
gd <- VSpec(DF2, 'wf', VLabel='filtered w', type='MEM', ADD=gd) + theme_WAC()
print (gd)

@

<<mv6, include=TRUE, echo=TRUE, fig.cap='Effect of inserting 6-sample missing gaps starting at 2 percent of the points.'>>=

DFM6 <- DF
ix <- runif(1800, 1, nrow(DFM6))
if (max(ix) > 89994) {ix <- ix[-which(ix > 89994)]}
for (j in 0:5) {
  DFM6$w[ix+j] <- NA
}
g <- VSpec(DF, 'w', VLabel='unmodified', xlim=c(0.01,30), type='MEM')
VSpec(DFM6, 'w', VLabel='missing-6', type='MEM', ADD=g) + theme_WAC()

@
\begin{center}
\textsf{\textcolor{blue}{-- End of Memo --}}
\par\end{center}


\end{document}
